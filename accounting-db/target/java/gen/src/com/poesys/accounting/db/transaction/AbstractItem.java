/**
 * Copyright 2016 Poesys Associates. All rights reserved.
 */
// Generated by AndroMDA Poesys/DB cartridge: DO NOT EDIT DIRECTLY.
// Template: AbstractDbDto.vsl

package com.poesys.accounting.db.transaction;

import org.apache.log4j.Logger;

import com.poesys.db.pk.IPrimaryKey;

import com.poesys.db.dto.AbstractDto;

/**
 * <p> A data-access layer data-transfer object for the Item. This class is an abstract class that
 * contains AndroMDA generated code; change nothing in this class. Instead, override any methods in
 * the concrete subclass generated in the same package. AndroMDA will overwrite this class each time
 * you run it but will never overwrite the concrete subclass. </p> <p> A specific amount of value
 * associated with a specific account within a transaction parent; the item debits and credits must
 * cancel each other out for the set of all items belonging to the transaction (the transaction must
 * "balance"); the transaction orders the set of items according to an integer order number, which
 * is part of the primary key </p> <p> Stereotypes: </p> <ul> <li>CompositeKey</li>
 * <li>Persistent</li> </ul> <p> Class is read/write: true </p>
 *
 * @author Poesys/DB Cartridge
 */
public abstract class AbstractItem extends AbstractDto implements IItem {
  /** Default serial version UID for the Serializable DTO */
  private static final long serialVersionUID = 1L;

  /** Logger for this class */
  private static final Logger logger = Logger.getLogger(AbstractItem.class);

  /** the deserializer used by the readObject method */
  private static final com.poesys.db.dto.Deserializer<AbstractItem> deserializer =
    new com.poesys.db.dto.Deserializer<AbstractItem>();

  // Setter strategy nested classes for single-object associations

  /**
   * Nested class that manages the transaction association data
   *
   * Source: AddToOneAssociationRequiredObjectProperties
   *
   * @author Poesys/DB Cartridge
   */
  private class QueryTransactionSetter extends com.poesys.db.dto.AbstractObjectSetter<com.poesys
    .accounting.db.transaction.ITransaction> {
    private static final long serialVersionUID = 1L;

    /**
     * Create a QueryTransactionSetter object.
     */
    public QueryTransactionSetter() {
      super("com.poesys.accounting.db.transaction", 2147483647);
    }

    @Override
    protected String getClassName() {
      return com.poesys.accounting.db.transaction.Transaction.class.getName();
    }

    @Override
    protected IPrimaryKey getKey() {
      return transactionKey;
    }

    @Override
    protected com.poesys.db.dao.query.IKeyQuerySql<com.poesys.accounting.db.transaction
      .ITransaction> getSql() {
      return new com.poesys.accounting.db.transaction.sql.QueryTransaction();
    }

    @Override
    protected void set(com.poesys.accounting.db.transaction.ITransaction dto) {
      // No status change, this is just filling in the object data.
      transaction = dto;
    }

    @Override
    public boolean isSet() {
      // Object is set if the associated transaction is not null
      return transaction != null;
    }
  }

  /**
   * Post-process setter for post-processing nested object property transaction.
   */
  private class PostProcessTransactionSetter extends com.poesys.db.dto.AbstractPostProcessSetter {
    // Property transaction source: AddToOneAssociationRequiredObjectProperties
    private static final long serialVersionUID = 1L;

    /**
     * Create a PostProcessTransactionSetter object.
     */
    public PostProcessTransactionSetter() {
      super("com.poesys.accounting.db.transaction", 2147483647);
    }

    @Override
    protected String getClassName() {
      return com.poesys.accounting.db.transaction.Transaction.class.getName();
    }

    @SuppressWarnings("unchecked")
    @Override
    protected java.util.Collection<com.poesys.db.dto.IDbDto> getDtos() {
      java.util.ArrayList<com.poesys.db.dto.IDbDto> array =
        new java.util.ArrayList<com.poesys.db.dto.IDbDto>(1);
      if (transaction != null) {
        array.add(transaction);
      }
      java.util.Collection<? extends com.poesys.db.dto.IDbDto> dtos = array;
      return (java.util.Collection<com.poesys.db.dto.IDbDto>)dtos;
    }
  }

  /**
   * Insert setter for inserting nested object property transaction.
   */
  private class InsertTransactionSetter extends com.poesys.db.dto.AbstractInsertSetter {
    // Property transaction source: AddToOneAssociationRequiredObjectProperties
    private static final long serialVersionUID = 1L;

    /**
     * Create an InsertTransactionSetter object.
     */
    public InsertTransactionSetter() {
      super("com.poesys.accounting.db.transaction", 2147483647);
    }

    @Override
    protected String getClassName() {
      return com.poesys.accounting.db.transaction.Transaction.class.getName();
    }

    @SuppressWarnings("unchecked")
    @Override
    protected java.util.Collection<com.poesys.db.dto.IDbDto> getDtos() {
      java.util.ArrayList<com.poesys.db.dto.IDbDto> array =
        new java.util.ArrayList<com.poesys.db.dto.IDbDto>(1);
      array.add(transaction);
      java.util.Collection<? extends com.poesys.db.dto.IDbDto> dtos = array;
      return (java.util.Collection<com.poesys.db.dto.IDbDto>)dtos;
    }

    @Override
    protected boolean createKey() {
      // Key type: SequenceKey
      return true;
    }
  }

  /**
   * Setter for processing added transaction, updated transaction, and deleted transaction.
   */

  private class UpdateTransactionSetter extends com.poesys.db.dto.AbstractProcessNestedObject<com
    .poesys.accounting.db.transaction.ITransaction> {
    private static final long serialVersionUID = 1L;

    /**
     * Create an UpdateTransactionSetter object.
     */
    public UpdateTransactionSetter() {
      super("com.poesys.accounting.db.transaction", 2147483647);
    }

    @Override
    protected void doChanged(com.poesys.accounting.db.transaction.ITransaction dto) {
      // transaction source: AddToOneAssociationRequiredObjectProperties
      // Immutable: false
      com.poesys.db.dao.IDaoManager manager =
        com.poesys.db.dao.DaoManagerFactory.getManager(subsystem);
      com.poesys.db.dao.IDaoFactory<com.poesys.accounting.db.transaction.ITransaction> factory =
        manager.getFactory(com.poesys.accounting.db.transaction.Transaction.class.getName(),
                           subsystem, 2147483647);
      com.poesys.db.dao.update.IUpdate<com.poesys.accounting.db.transaction.ITransaction> updater =
        factory.getUpdate(new com.poesys.accounting.db.transaction.sql.UpdateTransaction());

      updater.update(dto);
      // Complete the update by setting the DTO to EXISTING status.
      dto.setExisting();
    }

    @Override
    protected void doDeleted(com.poesys.accounting.db.transaction.ITransaction dto) {
      com.poesys.db.dao.IDaoManager manager =
        com.poesys.db.dao.DaoManagerFactory.getManager(subsystem);
      com.poesys.db.dao.IDaoFactory<com.poesys.accounting.db.transaction.ITransaction> factory =
        manager.getFactory(com.poesys.accounting.db.transaction.Transaction.class.getName(),
                           subsystem, 2147483647);
      com.poesys.db.dao.delete.IDelete<com.poesys.accounting.db.transaction.ITransaction> dao =
        factory.getDelete(new com.poesys.accounting.db.transaction.sql.DeleteTransaction());
      dao.delete(dto);
    }

    @Override
    protected void doNew(com.poesys.accounting.db.transaction.ITransaction dto) {
      com.poesys.db.dao.IDaoManager manager =
        com.poesys.db.dao.DaoManagerFactory.getManager(subsystem);
      com.poesys.db.dao.IDaoFactory<com.poesys.accounting.db.transaction.ITransaction> factory =
        manager.getFactory(com.poesys.accounting.db.transaction.Transaction.class.getName(),
                           subsystem, 2147483647);
      com.poesys.db.dao.insert.IInsert<com.poesys.accounting.db.transaction.ITransaction> inserter =
        factory.getInsert(new com.poesys.accounting.db.transaction.sql.InsertTransaction(),
                          createKey());

      // Insert the superclass objects from the root down. Suppress nested
      // inserts for the superclasses, wait until the concrete class. Also set 
      // pre-insert suppression off to have the root insert linked, to-one class
      // objects.
      dto.setSuppressNestedInserts(true);
      dto.setSuppressNestedPreInserts(false);

      // Suppress inserts in concrete class.
      dto.setSuppressNestedPreInserts(true);

      // Insert the object of the current class after enabling nested inserts,
      // which will allow connecting up linked objects to any of the inserted
      // classes.
      dto.setSuppressNestedInserts(false);
      inserter.insert(dto);
    }

    @Override
    protected com.poesys.accounting.db.transaction.ITransaction getDto() {
      return transaction;
    }

    @Override
    protected String getClassName() {
      return com.poesys.accounting.db.transaction.Transaction.class.getName();
    }

    @Override
    protected boolean createKey() {
      // Key type: SequenceKey
      return true;
    }
  }

  /**
   * Foreign key object used by QueryTransactionSetter nested class to query object
   */
  private IPrimaryKey transactionKey;

  /**
   * Set the foreign key transactionKey. This has package access to enable the subsystem factory
   * getData method to call this method to set the key by creating it from the queried result set.
   *
   * @param transactionKey the foreign key
   */
  void setTransactionKey(IPrimaryKey transactionKey) {
    this.transactionKey = transactionKey;
  }

  /**
   * Nested class that manages the account association data
   *
   * Source: AddToOneAssociationRequiredObjectProperties
   *
   * @author Poesys/DB Cartridge
   */
  private class QueryAccountSetter extends com.poesys.db.dto.AbstractObjectSetter<com.poesys
    .accounting.db.account.IAccount> {
    private static final long serialVersionUID = 1L;

    /**
     * Create a QueryAccountSetter object.
     */
    public QueryAccountSetter() {
      super("com.poesys.accounting.db.account", 2147483647);
    }

    @Override
    protected String getClassName() {
      return com.poesys.accounting.db.account.Account.class.getName();
    }

    @Override
    protected IPrimaryKey getKey() {
      return accountKey;
    }

    @Override
    protected com.poesys.db.dao.query.IKeyQuerySql<com.poesys.accounting.db.account.IAccount>
    getSql() {
      return new com.poesys.accounting.db.account.sql.QueryAccount();
    }

    @Override
    protected void set(com.poesys.accounting.db.account.IAccount dto) {
      // No status change, this is just filling in the object data.
      account = dto;
    }

    @Override
    public boolean isSet() {
      // Object is set if the associated account is not null
      return account != null;
    }
  }

  /**
   * Post-process setter for post-processing nested object property account.
   */
  private class PostProcessAccountSetter extends com.poesys.db.dto.AbstractPostProcessSetter {
    // Property account source: AddToOneAssociationRequiredObjectProperties
    private static final long serialVersionUID = 1L;

    /**
     * Create a PostProcessAccountSetter object.
     */
    public PostProcessAccountSetter() {
      super("com.poesys.accounting.db.account", 2147483647);
    }

    @Override
    protected String getClassName() {
      return com.poesys.accounting.db.account.Account.class.getName();
    }

    @SuppressWarnings("unchecked")
    @Override
    protected java.util.Collection<com.poesys.db.dto.IDbDto> getDtos() {
      java.util.ArrayList<com.poesys.db.dto.IDbDto> array =
        new java.util.ArrayList<com.poesys.db.dto.IDbDto>(1);
      if (account != null) {
        array.add(account);
      }
      java.util.Collection<? extends com.poesys.db.dto.IDbDto> dtos = array;
      return (java.util.Collection<com.poesys.db.dto.IDbDto>)dtos;
    }
  }

  /**
   * Insert setter for inserting nested object property account.
   */
  private class InsertAccountSetter extends com.poesys.db.dto.AbstractInsertSetter {
    // Property account source: AddToOneAssociationRequiredObjectProperties
    private static final long serialVersionUID = 1L;

    /**
     * Create an InsertAccountSetter object.
     */
    public InsertAccountSetter() {
      super("com.poesys.accounting.db.account", 2147483647);
    }

    @Override
    protected String getClassName() {
      return com.poesys.accounting.db.account.Account.class.getName();
    }

    @SuppressWarnings("unchecked")
    @Override
    protected java.util.Collection<com.poesys.db.dto.IDbDto> getDtos() {
      java.util.ArrayList<com.poesys.db.dto.IDbDto> array =
        new java.util.ArrayList<com.poesys.db.dto.IDbDto>(1);
      array.add(account);
      java.util.Collection<? extends com.poesys.db.dto.IDbDto> dtos = array;
      return (java.util.Collection<com.poesys.db.dto.IDbDto>)dtos;
    }

    @Override
    protected boolean createKey() {
      // Key type: CompositeKey
      return true;
    }
  }

  /**
   * Setter for processing added account, updated account, and deleted account.
   */

  private class UpdateAccountSetter extends com.poesys.db.dto.AbstractProcessNestedObject<com
    .poesys.accounting.db.account.IAccount> {
    private static final long serialVersionUID = 1L;

    /**
     * Create an UpdateAccountSetter object.
     */
    public UpdateAccountSetter() {
      super("com.poesys.accounting.db.account", 2147483647);
    }

    @Override
    protected void doChanged(com.poesys.accounting.db.account.IAccount dto) {
      // account source: AddToOneAssociationRequiredObjectProperties
      // Immutable: false
      com.poesys.db.dao.IDaoManager manager =
        com.poesys.db.dao.DaoManagerFactory.getManager(subsystem);
      com.poesys.db.dao.IDaoFactory<com.poesys.accounting.db.account.IAccount> factory =
        manager.getFactory(com.poesys.accounting.db.account.Account.class.getName(), subsystem,
                           2147483647);
      com.poesys.db.dao.update.IUpdate<com.poesys.accounting.db.account.IAccount> updater =
        factory.getUpdate(new com.poesys.accounting.db.account.sql.UpdateAccount());

      updater.update(dto);
      // Complete the update by setting the DTO to EXISTING status.
      dto.setExisting();
    }

    @Override
    protected void doDeleted(com.poesys.accounting.db.account.IAccount dto) {
      com.poesys.db.dao.IDaoManager manager =
        com.poesys.db.dao.DaoManagerFactory.getManager(subsystem);
      com.poesys.db.dao.IDaoFactory<com.poesys.accounting.db.account.IAccount> factory =
        manager.getFactory(com.poesys.accounting.db.account.Account.class.getName(), subsystem,
                           2147483647);
      com.poesys.db.dao.delete.IDelete<com.poesys.accounting.db.account.IAccount> dao =
        factory.getDelete(new com.poesys.accounting.db.account.sql.DeleteAccount());
      dao.delete(dto);
    }

    @Override
    protected void doNew(com.poesys.accounting.db.account.IAccount dto) {
      com.poesys.db.dao.IDaoManager manager =
        com.poesys.db.dao.DaoManagerFactory.getManager(subsystem);
      com.poesys.db.dao.IDaoFactory<com.poesys.accounting.db.account.IAccount> factory =
        manager.getFactory(com.poesys.accounting.db.account.Account.class.getName(), subsystem,
                           2147483647);
      com.poesys.db.dao.insert.IInsert<com.poesys.accounting.db.account.IAccount> inserter =
        factory.getInsert(new com.poesys.accounting.db.account.sql.InsertAccount(), createKey());

      // Insert the superclass objects from the root down. Suppress nested
      // inserts for the superclasses, wait until the concrete class. Also set 
      // pre-insert suppression off to have the root insert linked, to-one class
      // objects.
      dto.setSuppressNestedInserts(true);
      dto.setSuppressNestedPreInserts(false);

      // Suppress inserts in concrete class.
      dto.setSuppressNestedPreInserts(true);

      // Insert the object of the current class after enabling nested inserts,
      // which will allow connecting up linked objects to any of the inserted
      // classes.
      dto.setSuppressNestedInserts(false);
      inserter.insert(dto);
    }

    @Override
    protected com.poesys.accounting.db.account.IAccount getDto() {
      return account;
    }

    @Override
    protected String getClassName() {
      return com.poesys.accounting.db.account.Account.class.getName();
    }

    @Override
    protected boolean createKey() {
      // Key type: CompositeKey
      return true;
    }
  }

  /**
   * Foreign key object used by QueryAccountSetter nested class to query object
   */
  private IPrimaryKey accountKey;

  /**
   * Set the foreign key accountKey. This has package access to enable the subsystem factory getData
   * method to call this method to set the key by creating it from the queried result set.
   *
   * @param accountKey the foreign key
   */
  void setAccountKey(IPrimaryKey accountKey) {
    this.accountKey = accountKey;
  }

  // Setter strategy nested classes for multiple-object associations

  /**
   * Post-processing setter for post-processing nested to-many association reimbursingItem.
   */
  private class PostProcessReimbursingItemsSetter extends com.poesys.db.dto
    .AbstractPostProcessSetter {
    private static final long serialVersionUID = 1L;

    // Association reimbursingItems source: TransformToProperty +
    // AddToManyAssociationCollectionProperties

    /**
     * Create an PostProcessReimbursingItemsSetter object.
     */
    public PostProcessReimbursingItemsSetter() {
      super("com.poesys.accounting.db.transaction", 2147483647);
    }

    @Override
    protected String getClassName() {
      return com.poesys.accounting.db.transaction.Item.class.getName();
    }

    @SuppressWarnings("unchecked")
    @Override
    protected java.util.Collection<com.poesys.db.dto.IDbDto> getDtos() {
      java.util.Collection<? extends com.poesys.db.dto.IDbDto> dtos = reimbursingItems;
      return (java.util.Collection<com.poesys.db.dto.IDbDto>)dtos;
    }
  }

  /**
   * Insert setter for inserting nested to-many association reimbursingItem.
   *
   * @see com.poesys.accounting.db.transaction.sql.InsertItem
   */
  private class InsertReimbursingItemsSetter extends com.poesys.db.dto.AbstractInsertSetter {
    private static final long serialVersionUID = 1L;

    // Association reimbursingItems source: TransformToProperty +
    // AddToManyAssociationCollectionProperties

    /**
     * Create an InsertReimbursingItemsSetter object.
     */
    public InsertReimbursingItemsSetter() {
      super("com.poesys.accounting.db.transaction", 2147483647);
    }

    @Override
    protected String getClassName() {
      return com.poesys.accounting.db.transaction.Item.class.getName();
    }

    @SuppressWarnings("unchecked")
    @Override
    protected java.util.Collection<com.poesys.db.dto.IDbDto> getDtos() {
      java.util.Collection<? extends com.poesys.db.dto.IDbDto> dtos = reimbursingItems;
      return (java.util.Collection<com.poesys.db.dto.IDbDto>)dtos;
    }

    @Override
    protected boolean createKey() {
      return true;
    }
  }

  /**
   * Setter for processing added reimbursingItem, updated reimbursingItem, and deleted
   * reimbursingItem.
   */

  private class UpdateReimbursingItemsSetter extends com.poesys.db.dto
    .AbstractProcessNestedObjects<com.poesys.accounting.db.transaction.IItem, java.util
    .Collection<com.poesys.accounting.db.transaction.IItem>> {
    private static final long serialVersionUID = 1L;
    private static final int BATCH_SIZE = 100;

    /**
     * Create an UpdateReimbursingItemsSetter object.
     */
    public UpdateReimbursingItemsSetter() {
      super("com.poesys.accounting.db.transaction", 2147483647);
    }

    @Override
    protected void doChanged(java.util.Collection<com.poesys.accounting.db.transaction.IItem>
                                   dtos) {
      // reimbursingItems source: TransformToProperty + AddToManyAssociationCollectionProperties
      // Immutable: false
      com.poesys.db.dao.IDaoManager manager =
        com.poesys.db.dao.DaoManagerFactory.getManager(subsystem);

      com.poesys.db.dao.IDaoFactory<com.poesys.accounting.db.transaction.IItem> factory =
        manager.getFactory(com.poesys.accounting.db.transaction.Item.class.getName(), subsystem,
                           2147483647);
      com.poesys.db.dao.update.IUpdateBatch<com.poesys.accounting.db.transaction.IItem> updater =
        factory.getUpdateBatch(new com.poesys.accounting.db.transaction.sql.UpdateItem());

      // Update the object of the leaf class.
      updater.update(dtos, dtos.size() / 2);
      // Complete the update by setting the DTOs to EXISTING status.
      for (com.poesys.db.dto.IDbDto dto : dtos) {
        if (dto.getStatus() == Status.CHANGED) {
          dto.setExisting();
        }
      }
    }

    @Override
    protected void doDeleted(java.util.Collection<com.poesys.accounting.db.transaction.IItem>
                                   dtos) {
      com.poesys.db.dao.IDaoManager manager =
        com.poesys.db.dao.DaoManagerFactory.getManager(subsystem);
      com.poesys.db.dao.IDaoFactory<com.poesys.accounting.db.transaction.IItem> factory =
        manager.getFactory(com.poesys.accounting.db.transaction.Item.class.getName(), subsystem,
                           2147483647);
      com.poesys.db.dao.delete.IDeleteBatch<com.poesys.accounting.db.transaction.IItem> dao =
        factory.getDeleteBatch(new com.poesys.accounting.db.transaction.sql.DeleteItem());
      dao.delete(dtos, BATCH_SIZE);
    }

    @Override
    protected void doNew(java.util.Collection<com.poesys.accounting.db.transaction.IItem> dtos) {
      com.poesys.db.dao.IDaoManager manager =
        com.poesys.db.dao.DaoManagerFactory.getManager(subsystem);

      com.poesys.db.dao.IDaoFactory<com.poesys.accounting.db.transaction.IItem> factory =
        manager.getFactory(com.poesys.accounting.db.transaction.Item.class.getName(), subsystem,
                           2147483647);
      com.poesys.db.dao.insert.IInsertBatch<com.poesys.accounting.db.transaction.IItem> inserter =
        factory.getInsertBatch(new com.poesys.accounting.db.transaction.sql.InsertItem());

      // Insert the object of the current class after enabling nested inserts,
      // which will allow connecting up linked objects to any of the inserted
      // classes.
      for (com.poesys.db.dto.IDbDto dto : dtos) {
        dto.setSuppressNestedInserts(false);
      }
      inserter.insert(dtos, dtos.size() / 2);
    }

    @Override
    protected java.util.Collection<com.poesys.accounting.db.transaction.IItem> getDtos() {
      return reimbursingItems;
    }

    @Override
    protected String getClassName() {
      return com.poesys.accounting.db.transaction.Item.class.getName();
    }
  }

  /**
   * Add com.poesys.accounting.db.transaction.IItem object to reimbursingItems collection.
   *
   * @param object the com.poesys.accounting.db.transaction.IItem object
   */
  public void addReimbursingItemsItem(com.poesys.accounting.db.transaction.IItem object) {
    if (reimbursingItems == null) {
      // Association not yet created, create it.
      reimbursingItems = new java.util.ArrayList<com.poesys.accounting.db.transaction.IItem>();
    }
    reimbursingItems.add(object);
    // Add the primary key to the primary key array.
    if (reimbursingItemKeys != null) {
      reimbursingItemKeys.clear();
    } else {
      reimbursingItemKeys = new java.util.ArrayList<com.poesys.db.pk.IPrimaryKey>();
    }
    reimbursingItemKeys.add(object.getPrimaryKey());
  }

  /**
   * Post-processing setter for post-processing nested to-many association receivable.
   */
  private class PostProcessReceivablesSetter extends com.poesys.db.dto.AbstractPostProcessSetter {
    private static final long serialVersionUID = 1L;

    // Association receivables source: TransformToProperty +
    // AddToManyAssociationCollectionProperties

    /**
     * Create an PostProcessReceivablesSetter object.
     */
    public PostProcessReceivablesSetter() {
      super("com.poesys.accounting.db.transaction", 2147483647);
    }

    @Override
    protected String getClassName() {
      return com.poesys.accounting.db.transaction.Item.class.getName();
    }

    @SuppressWarnings("unchecked")
    @Override
    protected java.util.Collection<com.poesys.db.dto.IDbDto> getDtos() {
      java.util.Collection<? extends com.poesys.db.dto.IDbDto> dtos = receivables;
      return (java.util.Collection<com.poesys.db.dto.IDbDto>)dtos;
    }
  }

  /**
   * Insert setter for inserting nested to-many association receivable.
   *
   * @see com.poesys.accounting.db.transaction.sql.InsertItem
   */
  private class InsertReceivablesSetter extends com.poesys.db.dto.AbstractInsertSetter {
    private static final long serialVersionUID = 1L;

    // Association receivables source: TransformToProperty +
    // AddToManyAssociationCollectionProperties

    /**
     * Create an InsertReceivablesSetter object.
     */
    public InsertReceivablesSetter() {
      super("com.poesys.accounting.db.transaction", 2147483647);
    }

    @Override
    protected String getClassName() {
      return com.poesys.accounting.db.transaction.Item.class.getName();
    }

    @SuppressWarnings("unchecked")
    @Override
    protected java.util.Collection<com.poesys.db.dto.IDbDto> getDtos() {
      java.util.Collection<? extends com.poesys.db.dto.IDbDto> dtos = receivables;
      return (java.util.Collection<com.poesys.db.dto.IDbDto>)dtos;
    }

    @Override
    protected boolean createKey() {
      return true;
    }
  }

  /**
   * Setter for processing added receivable, updated receivable, and deleted receivable.
   */

  private class UpdateReceivablesSetter extends com.poesys.db.dto
    .AbstractProcessNestedObjects<com.poesys.accounting.db.transaction.IItem, java.util
    .Collection<com.poesys.accounting.db.transaction.IItem>> {
    private static final long serialVersionUID = 1L;
    private static final int BATCH_SIZE = 100;

    /**
     * Create an UpdateReceivablesSetter object.
     */
    public UpdateReceivablesSetter() {
      super("com.poesys.accounting.db.transaction", 2147483647);
    }

    @Override
    protected void doChanged(java.util.Collection<com.poesys.accounting.db.transaction.IItem>
                                   dtos) {
      // receivables source: TransformToProperty + AddToManyAssociationCollectionProperties
      // Immutable: false
      com.poesys.db.dao.IDaoManager manager =
        com.poesys.db.dao.DaoManagerFactory.getManager(subsystem);

      com.poesys.db.dao.IDaoFactory<com.poesys.accounting.db.transaction.IItem> factory =
        manager.getFactory(com.poesys.accounting.db.transaction.Item.class.getName(), subsystem,
                           2147483647);
      com.poesys.db.dao.update.IUpdateBatch<com.poesys.accounting.db.transaction.IItem> updater =
        factory.getUpdateBatch(new com.poesys.accounting.db.transaction.sql.UpdateItem());

      // Update the object of the leaf class.
      updater.update(dtos, dtos.size() / 2);
      // Complete the update by setting the DTOs to EXISTING status.
      for (com.poesys.db.dto.IDbDto dto : dtos) {
        if (dto.getStatus() == Status.CHANGED) {
          dto.setExisting();
        }
      }
    }

    @Override
    protected void doDeleted(java.util.Collection<com.poesys.accounting.db.transaction.IItem>
                                   dtos) {
      com.poesys.db.dao.IDaoManager manager =
        com.poesys.db.dao.DaoManagerFactory.getManager(subsystem);
      com.poesys.db.dao.IDaoFactory<com.poesys.accounting.db.transaction.IItem> factory =
        manager.getFactory(com.poesys.accounting.db.transaction.Item.class.getName(), subsystem,
                           2147483647);
      com.poesys.db.dao.delete.IDeleteBatch<com.poesys.accounting.db.transaction.IItem> dao =
        factory.getDeleteBatch(new com.poesys.accounting.db.transaction.sql.DeleteItem());
      dao.delete(dtos, BATCH_SIZE);
    }

    @Override
    protected void doNew(java.util.Collection<com.poesys.accounting.db.transaction.IItem> dtos) {
      com.poesys.db.dao.IDaoManager manager =
        com.poesys.db.dao.DaoManagerFactory.getManager(subsystem);

      com.poesys.db.dao.IDaoFactory<com.poesys.accounting.db.transaction.IItem> factory =
        manager.getFactory(com.poesys.accounting.db.transaction.Item.class.getName(), subsystem,
                           2147483647);
      com.poesys.db.dao.insert.IInsertBatch<com.poesys.accounting.db.transaction.IItem> inserter =
        factory.getInsertBatch(new com.poesys.accounting.db.transaction.sql.InsertItem());

      // Insert the object of the current class after enabling nested inserts,
      // which will allow connecting up linked objects to any of the inserted
      // classes.
      for (com.poesys.db.dto.IDbDto dto : dtos) {
        dto.setSuppressNestedInserts(false);
      }
      inserter.insert(dtos, dtos.size() / 2);
    }

    @Override
    protected java.util.Collection<com.poesys.accounting.db.transaction.IItem> getDtos() {
      return receivables;
    }

    @Override
    protected String getClassName() {
      return com.poesys.accounting.db.transaction.Item.class.getName();
    }
  }

  /**
   * Add com.poesys.accounting.db.transaction.IItem object to receivables collection.
   *
   * @param object the com.poesys.accounting.db.transaction.IItem object
   */
  public void addReceivablesItem(com.poesys.accounting.db.transaction.IItem object) {
    if (receivables == null) {
      // Association not yet created, create it.
      receivables = new java.util.ArrayList<com.poesys.accounting.db.transaction.IItem>();
    }
    receivables.add(object);
    // Add the primary key to the primary key array.
    if (receivableKeys != null) {
      receivableKeys.clear();
    } else {
      receivableKeys = new java.util.ArrayList<com.poesys.db.pk.IPrimaryKey>();
    }
    receivableKeys.add(object.getPrimaryKey());
  }

  /**
   * Post-processing setter for post-processing nested to-many association
   * reimbursingItemsReimbursement.
   */
  private class PostProcessReimbursingItemsReimbursementSetter extends com.poesys.db.dto
    .AbstractPostProcessSetter {
    private static final long serialVersionUID = 1L;

    // Association reimbursingItemsReimbursement source: AddAssociationClassCollectionProperties

    /**
     * Create an PostProcessReimbursingItemsReimbursementSetter object.
     */
    public PostProcessReimbursingItemsReimbursementSetter() {
      super("com.poesys.accounting.db.transaction", 2147483647);
    }

    @Override
    protected String getClassName() {
      return com.poesys.accounting.db.transaction.Reimbursement.class.getName();
    }

    @SuppressWarnings("unchecked")
    @Override
    protected java.util.Collection<com.poesys.db.dto.IDbDto> getDtos() {
      java.util.Collection<? extends com.poesys.db.dto.IDbDto> dtos = reimbursingItemsReimbursement;
      return (java.util.Collection<com.poesys.db.dto.IDbDto>)dtos;
    }
  }

  /**
   * Insert setter for inserting nested to-many association reimbursingItemsReimbursement.
   *
   * @see com.poesys.accounting.db.transaction.sql.InsertReimbursement
   */
  private class InsertReimbursingItemsReimbursementSetter extends com.poesys.db.dto
    .AbstractInsertSetter {
    private static final long serialVersionUID = 1L;

    // Association reimbursingItemsReimbursement source: AddAssociationClassCollectionProperties

    /**
     * Create an InsertReimbursingItemsReimbursementSetter object.
     */
    public InsertReimbursingItemsReimbursementSetter() {
      super("com.poesys.accounting.db.transaction", 2147483647);
    }

    @Override
    protected String getClassName() {
      return com.poesys.accounting.db.transaction.Reimbursement.class.getName();
    }

    @SuppressWarnings("unchecked")
    @Override
    protected java.util.Collection<com.poesys.db.dto.IDbDto> getDtos() {
      java.util.Collection<? extends com.poesys.db.dto.IDbDto> dtos = reimbursingItemsReimbursement;
      return (java.util.Collection<com.poesys.db.dto.IDbDto>)dtos;
    }

    @Override
    protected boolean createKey() {
      return true;
    }
  }

  /**
   * Setter for processing added reimbursingItemsReimbursement and updated
   * reimbursingItemsReimbursement. Deleted reimbursingItemsReimbursement are deleted in the
   * database cascade delete.
   */

  private class UpdateReimbursingItemsReimbursementSetter extends com.poesys.db.dto
    .AbstractProcessNestedObjects<com.poesys.accounting.db.transaction.IReimbursement, java.util
    .Collection<com.poesys.accounting.db.transaction.IReimbursement>> {
    private static final long serialVersionUID = 1L;
    private static final int BATCH_SIZE = 100;

    /**
     * Create an UpdateReimbursingItemsReimbursementSetter object.
     */
    public UpdateReimbursingItemsReimbursementSetter() {
      super("com.poesys.accounting.db.transaction", 2147483647);
    }

    @Override
    protected void doChanged(java.util.Collection<com.poesys.accounting.db.transaction
      .IReimbursement> dtos) {
      // reimbursingItemsReimbursement source: AddAssociationClassCollectionProperties
      // Immutable: false
      com.poesys.db.dao.IDaoManager manager =
        com.poesys.db.dao.DaoManagerFactory.getManager(subsystem);

      com.poesys.db.dao.IDaoFactory<com.poesys.accounting.db.transaction.IReimbursement> factory =
        manager.getFactory(com.poesys.accounting.db.transaction.Reimbursement.class.getName(),
                           subsystem, 2147483647);
      com.poesys.db.dao.update.IUpdateBatch<com.poesys.accounting.db.transaction.IReimbursement>
        updater =
        factory.getUpdateBatch(new com.poesys.accounting.db.transaction.sql.UpdateReimbursement());

      // Update the object of the leaf class.
      updater.update(dtos, dtos.size() / 2);
      // Complete the update by setting the DTOs to EXISTING status.
      for (com.poesys.db.dto.IDbDto dto : dtos) {
        if (dto.getStatus() == Status.CHANGED) {
          dto.setExisting();
        }
      }
    }

    @Override
    protected void doDeleted(java.util.Collection<com.poesys.accounting.db.transaction
      .IReimbursement> dtos) {
      com.poesys.db.dao.IDaoManager manager =
        com.poesys.db.dao.DaoManagerFactory.getManager(subsystem);
      com.poesys.db.dao.IDaoFactory<com.poesys.accounting.db.transaction.IReimbursement> factory =
        manager.getFactory(com.poesys.accounting.db.transaction.Reimbursement.class.getName(),
                           subsystem, 2147483647);
      com.poesys.db.dao.delete.IDeleteBatch<com.poesys.accounting.db.transaction.IReimbursement>
        dao =
        factory.getDeleteBatch(new com.poesys.accounting.db.transaction.sql.DeleteReimbursement());
      dao.delete(dtos, BATCH_SIZE);
    }

    @Override
    protected void doNew(java.util.Collection<com.poesys.accounting.db.transaction
      .IReimbursement> dtos) {
      com.poesys.db.dao.IDaoManager manager =
        com.poesys.db.dao.DaoManagerFactory.getManager(subsystem);

      com.poesys.db.dao.IDaoFactory<com.poesys.accounting.db.transaction.IReimbursement> factory =
        manager.getFactory(com.poesys.accounting.db.transaction.Reimbursement.class.getName(),
                           subsystem, 2147483647);
      com.poesys.db.dao.insert.IInsertBatch<com.poesys.accounting.db.transaction.IReimbursement>
        inserter =
        factory.getInsertBatch(new com.poesys.accounting.db.transaction.sql.InsertReimbursement());

      // Insert the object of the current class after enabling nested inserts,
      // which will allow connecting up linked objects to any of the inserted
      // classes.
      for (com.poesys.db.dto.IDbDto dto : dtos) {
        dto.setSuppressNestedInserts(false);
      }
      inserter.insert(dtos, dtos.size() / 2);
    }

    @Override
    protected java.util.Collection<com.poesys.accounting.db.transaction.IReimbursement> getDtos() {
      return reimbursingItemsReimbursement;
    }

    @Override
    protected String getClassName() {
      return com.poesys.accounting.db.transaction.Reimbursement.class.getName();
    }
  }

  /**
   * Add com.poesys.accounting.db.transaction.IReimbursement object to reimbursingItemsReimbursement
   * collection.
   *
   * @param object the com.poesys.accounting.db.transaction.IReimbursement object
   */
  public void addReimbursingItemsReimbursementReimbursement(com.poesys.accounting.db.transaction
                                                              .IReimbursement object) {
    if (reimbursingItemsReimbursement == null) {
      // Association not yet created, create it.
      reimbursingItemsReimbursement =
        new java.util.ArrayList<com.poesys.accounting.db.transaction.IReimbursement>();
    }
    reimbursingItemsReimbursement.add(object);
    // Add the primary key to the primary key array.
    if (reimbursingItemsReimbursementKeys != null) {
      reimbursingItemsReimbursementKeys.clear();
    } else {
      reimbursingItemsReimbursementKeys = new java.util.ArrayList<com.poesys.db.pk.IPrimaryKey>();
    }
    reimbursingItemsReimbursementKeys.add(object.getPrimaryKey());
  }

  /**
   * Post-processing setter for post-processing nested to-many association
   * receivablesReimbursement.
   */
  private class PostProcessReceivablesReimbursementSetter extends com.poesys.db.dto
    .AbstractPostProcessSetter {
    private static final long serialVersionUID = 1L;

    // Association receivablesReimbursement source: AddAssociationClassCollectionProperties

    /**
     * Create an PostProcessReceivablesReimbursementSetter object.
     */
    public PostProcessReceivablesReimbursementSetter() {
      super("com.poesys.accounting.db.transaction", 2147483647);
    }

    @Override
    protected String getClassName() {
      return com.poesys.accounting.db.transaction.Reimbursement.class.getName();
    }

    @SuppressWarnings("unchecked")
    @Override
    protected java.util.Collection<com.poesys.db.dto.IDbDto> getDtos() {
      java.util.Collection<? extends com.poesys.db.dto.IDbDto> dtos = receivablesReimbursement;
      return (java.util.Collection<com.poesys.db.dto.IDbDto>)dtos;
    }
  }

  /**
   * Insert setter for inserting nested to-many association receivablesReimbursement.
   *
   * @see com.poesys.accounting.db.transaction.sql.InsertReimbursement
   */
  private class InsertReceivablesReimbursementSetter extends com.poesys.db.dto
    .AbstractInsertSetter {
    private static final long serialVersionUID = 1L;

    // Association receivablesReimbursement source: AddAssociationClassCollectionProperties

    /**
     * Create an InsertReceivablesReimbursementSetter object.
     */
    public InsertReceivablesReimbursementSetter() {
      super("com.poesys.accounting.db.transaction", 2147483647);
    }

    @Override
    protected String getClassName() {
      return com.poesys.accounting.db.transaction.Reimbursement.class.getName();
    }

    @SuppressWarnings("unchecked")
    @Override
    protected java.util.Collection<com.poesys.db.dto.IDbDto> getDtos() {
      java.util.Collection<? extends com.poesys.db.dto.IDbDto> dtos = receivablesReimbursement;
      return (java.util.Collection<com.poesys.db.dto.IDbDto>)dtos;
    }

    @Override
    protected boolean createKey() {
      return true;
    }
  }

  /**
   * Setter for processing added receivablesReimbursement and updated receivablesReimbursement.
   * Deleted receivablesReimbursement are deleted in the database cascade delete.
   */

  private class UpdateReceivablesReimbursementSetter extends com.poesys.db.dto
    .AbstractProcessNestedObjects<com.poesys.accounting.db.transaction.IReimbursement, java.util
    .Collection<com.poesys.accounting.db.transaction.IReimbursement>> {
    private static final long serialVersionUID = 1L;
    private static final int BATCH_SIZE = 100;

    /**
     * Create an UpdateReceivablesReimbursementSetter object.
     */
    public UpdateReceivablesReimbursementSetter() {
      super("com.poesys.accounting.db.transaction", 2147483647);
    }

    @Override
    protected void doChanged(java.util.Collection<com.poesys.accounting.db.transaction
      .IReimbursement> dtos) {
      // receivablesReimbursement source: AddAssociationClassCollectionProperties
      // Immutable: false
      com.poesys.db.dao.IDaoManager manager =
        com.poesys.db.dao.DaoManagerFactory.getManager(subsystem);

      com.poesys.db.dao.IDaoFactory<com.poesys.accounting.db.transaction.IReimbursement> factory =
        manager.getFactory(com.poesys.accounting.db.transaction.Reimbursement.class.getName(),
                           subsystem, 2147483647);
      com.poesys.db.dao.update.IUpdateBatch<com.poesys.accounting.db.transaction.IReimbursement>
        updater =
        factory.getUpdateBatch(new com.poesys.accounting.db.transaction.sql.UpdateReimbursement());

      // Update the object of the leaf class.
      updater.update(dtos, dtos.size() / 2);
      // Complete the update by setting the DTOs to EXISTING status.
      for (com.poesys.db.dto.IDbDto dto : dtos) {
        if (dto.getStatus() == Status.CHANGED) {
          dto.setExisting();
        }
      }
    }

    @Override
    protected void doDeleted(java.util.Collection<com.poesys.accounting.db.transaction
      .IReimbursement> dtos) {
      com.poesys.db.dao.IDaoManager manager =
        com.poesys.db.dao.DaoManagerFactory.getManager(subsystem);
      com.poesys.db.dao.IDaoFactory<com.poesys.accounting.db.transaction.IReimbursement> factory =
        manager.getFactory(com.poesys.accounting.db.transaction.Reimbursement.class.getName(),
                           subsystem, 2147483647);
      com.poesys.db.dao.delete.IDeleteBatch<com.poesys.accounting.db.transaction.IReimbursement>
        dao =
        factory.getDeleteBatch(new com.poesys.accounting.db.transaction.sql.DeleteReimbursement());
      dao.delete(dtos, BATCH_SIZE);
    }

    @Override
    protected void doNew(java.util.Collection<com.poesys.accounting.db.transaction
      .IReimbursement> dtos) {
      com.poesys.db.dao.IDaoManager manager =
        com.poesys.db.dao.DaoManagerFactory.getManager(subsystem);

      com.poesys.db.dao.IDaoFactory<com.poesys.accounting.db.transaction.IReimbursement> factory =
        manager.getFactory(com.poesys.accounting.db.transaction.Reimbursement.class.getName(),
                           subsystem, 2147483647);
      com.poesys.db.dao.insert.IInsertBatch<com.poesys.accounting.db.transaction.IReimbursement>
        inserter =
        factory.getInsertBatch(new com.poesys.accounting.db.transaction.sql.InsertReimbursement());

      // Insert the object of the current class after enabling nested inserts,
      // which will allow connecting up linked objects to any of the inserted
      // classes.
      for (com.poesys.db.dto.IDbDto dto : dtos) {
        dto.setSuppressNestedInserts(false);
      }
      inserter.insert(dtos, dtos.size() / 2);
    }

    @Override
    protected java.util.Collection<com.poesys.accounting.db.transaction.IReimbursement> getDtos() {
      return receivablesReimbursement;
    }

    @Override
    protected String getClassName() {
      return com.poesys.accounting.db.transaction.Reimbursement.class.getName();
    }
  }

  /**
   * Add com.poesys.accounting.db.transaction.IReimbursement object to receivablesReimbursement
   * collection.
   *
   * @param object the com.poesys.accounting.db.transaction.IReimbursement object
   */
  public void addReceivablesReimbursementReimbursement(com.poesys.accounting.db.transaction
                                                         .IReimbursement object) {
    if (receivablesReimbursement == null) {
      // Association not yet created, create it.
      receivablesReimbursement =
        new java.util.ArrayList<com.poesys.accounting.db.transaction.IReimbursement>();
    }
    receivablesReimbursement.add(object);
    // Add the primary key to the primary key array.
    if (receivablesReimbursementKeys != null) {
      receivablesReimbursementKeys.clear();
    } else {
      receivablesReimbursementKeys = new java.util.ArrayList<com.poesys.db.pk.IPrimaryKey>();
    }
    receivablesReimbursementKeys.add(object.getPrimaryKey());
  }

  /**
   * Create an empty Item for use in building a new object. The concrete subclass must call this
   * constructor.
   */
  public AbstractItem() {
    abstractClass = false;
    createInserters();

    // Setter arrays (create if null)
    if (querySetters == null) {
      querySetters = new java.util.ArrayList<com.poesys.db.dto.ISet>();
    }
    if (insertSetters == null) {
      insertSetters = new java.util.ArrayList<com.poesys.db.dto.ISet>();
    }
    if (preSetters == null) {
      preSetters = new java.util.ArrayList<com.poesys.db.dto.ISet>();
    }
    if (postSetters == null) {
      postSetters = new java.util.ArrayList<com.poesys.db.dto.ISet>();
    }
    if (postProcessSetters == null) {
      postProcessSetters = new java.util.ArrayList<com.poesys.db.dto.ISet>();
    }
    if (readObjectSetters == null) {
      readObjectSetters = new java.util.ArrayList<com.poesys.db.dto.ISet>();
    }

    // Add the setters for the transaction property.
    querySetters.add(new QueryTransactionSetter());
    preSetters.add(new InsertTransactionSetter());
    postSetters.add(new UpdateTransactionSetter());
    postProcessSetters.add(new PostProcessTransactionSetter());

    // Add the setters for the account property.
    querySetters.add(new QueryAccountSetter());
    preSetters.add(new InsertAccountSetter());
    postSetters.add(new UpdateAccountSetter());
    postProcessSetters.add(new PostProcessAccountSetter());

    // Add the many-to-many collection setters for the reimbursingItems property.
    insertSetters.add(new InsertReimbursingItemsSetter());
    postSetters.add(new UpdateReimbursingItemsSetter());
    postProcessSetters.add(new PostProcessReimbursingItemsSetter());

    // Add the many-to-many collection setters for the receivables property.
    insertSetters.add(new InsertReceivablesSetter());
    postSetters.add(new UpdateReceivablesSetter());
    postProcessSetters.add(new PostProcessReceivablesSetter());

    // Add the many-to-many collection setters for the reimbursingItemsReimbursement property.
    insertSetters.add(new InsertReimbursingItemsReimbursementSetter());
    postSetters.add(new UpdateReimbursingItemsReimbursementSetter());
    postProcessSetters.add(new PostProcessReimbursingItemsReimbursementSetter());

    // Add the many-to-many collection setters for the receivablesReimbursement property.
    insertSetters.add(new InsertReceivablesReimbursementSetter());
    postSetters.add(new UpdateReceivablesReimbursementSetter());
    postProcessSetters.add(new PostProcessReceivablesReimbursementSetter());
  }

  /**
   * Create a Item. The concrete subclass must call this constructor.
   *
   * @param key           the primary key of the Item
   * @param transactionId composite super-key attribute that uniquely identifies child combined with
   *                      child sub-key and any other parent super-keys
   * @param orderNumber
   * @param amount        the monetary amount in dollars of the transaction item
   * @param debit         whether the item is a debit (true) or credit (false); default value is the
   *                      debit-default value of the account
   * @param checked       whether the value and details of the transaction item have been verified
   *                      and reconciled
   * @param accountName   foreign key used by setter to query associated object
   * @param entityName    foreign key used by setter to query associated object
   */
  public AbstractItem(IPrimaryKey key, java.math.BigInteger transactionId, java.lang.Integer
    orderNumber, java.lang.Double amount, java.lang.Boolean debit, java.lang.Boolean checked,
                      java.lang.String accountName, java.lang.String entityName) {
    this.key = key;

    this.transactionId = transactionId;

    if (transactionId == null) {
      throw new com.poesys.db.InvalidParametersException(
        "transactionId is required for " + key.getValueList());
    }

    this.orderNumber = orderNumber;

    if (orderNumber == null) {
      throw new com.poesys.db.InvalidParametersException(
        "orderNumber is required for " + key.getValueList());
    }

    this.amount = amount;

    if (amount == null) {
      throw new com.poesys.db.InvalidParametersException(
        "amount is required for " + key.getValueList());
    }

    this.debit = debit;

    if (debit == null) {
      throw new com.poesys.db.InvalidParametersException(
        "debit is required for " + key.getValueList());
    }

    this.checked = checked;

    if (checked == null) {
      throw new com.poesys.db.InvalidParametersException(
        "checked is required for " + key.getValueList());
    }

    this.accountName = accountName;

    if (accountName == null) {
      throw new com.poesys.db.InvalidParametersException(
        "accountName is required for " + key.getValueList());
    }

    this.entityName = entityName;

    if (entityName == null) {
      throw new com.poesys.db.InvalidParametersException(
        "entityName is required for " + key.getValueList());
    }

    // Setter arrays (create if null)
    if (querySetters == null) {
      querySetters = new java.util.ArrayList<com.poesys.db.dto.ISet>();
    }
    if (insertQuerySetters == null) {
      insertQuerySetters = new java.util.ArrayList<com.poesys.db.dto.ISet>();
    }
    if (insertSetters == null) {
      insertSetters = new java.util.ArrayList<com.poesys.db.dto.ISet>();
    }
    if (preSetters == null) {
      preSetters = new java.util.ArrayList<com.poesys.db.dto.ISet>();
    }
    if (postSetters == null) {
      postSetters = new java.util.ArrayList<com.poesys.db.dto.ISet>();
    }
    if (postProcessSetters == null) {
      postProcessSetters = new java.util.ArrayList<com.poesys.db.dto.ISet>();
    }
    if (readObjectSetters == null) {
      readObjectSetters = new java.util.ArrayList<com.poesys.db.dto.ISet>();
    }

    // Add the setters for the transaction property.
    querySetters.add(new QueryTransactionSetter());
    // Set the object property primary key with a factory method.
    transactionKey =
      com.poesys.accounting.db.transaction.TransactionFactory.getTransactionPrimaryKey(
        transactionId);
    insertSetters.add(new InsertTransactionSetter());
    preSetters.add(new InsertTransactionSetter());
    postSetters.add(new UpdateTransactionSetter());
    postProcessSetters.add(new PostProcessTransactionSetter());

    // Add a setter to instantiate the required transaction object before insert.
    insertQuerySetters.add(new QueryTransactionSetter());

    // Add the setters for the account property.
    querySetters.add(new QueryAccountSetter());
    // Set the object property primary key with a factory method.
    accountKey =
      com.poesys.accounting.db.account.AccountFactory.getAccountPrimaryKey(accountName, entityName);
    insertSetters.add(new InsertAccountSetter());
    preSetters.add(new InsertAccountSetter());
    postSetters.add(new UpdateAccountSetter());
    postProcessSetters.add(new PostProcessAccountSetter());

    // Add a setter to instantiate the required account object before insert.
    insertQuerySetters.add(new QueryAccountSetter());

    // Add the many-to-many collection setters for the reimbursingItem property.
    insertSetters.add(new InsertReimbursingItemsSetter());
    postSetters.add(new UpdateReimbursingItemsSetter());
    postProcessSetters.add(new PostProcessReimbursingItemsSetter());

    // Add the many-to-many collection setters for the receivable property.
    insertSetters.add(new InsertReceivablesSetter());
    postSetters.add(new UpdateReceivablesSetter());
    postProcessSetters.add(new PostProcessReceivablesSetter());

    // Add the many-to-many collection setters for the reimbursingItemsReimbursement property.
    insertSetters.add(new InsertReimbursingItemsReimbursementSetter());
    postSetters.add(new UpdateReimbursingItemsReimbursementSetter());
    postProcessSetters.add(new PostProcessReimbursingItemsReimbursementSetter());

    // Add the many-to-many collection setters for the receivablesReimbursement property.
    insertSetters.add(new InsertReceivablesReimbursementSetter());
    postSetters.add(new UpdateReceivablesReimbursementSetter());
    postProcessSetters.add(new PostProcessReceivablesReimbursementSetter());
    abstractClass = false;
    createInserters();
  }

  /**
   * Read an object from an input stream, de-serializing it. Each generated class must have this
   * private method, which the deserialize method calls through Java reflection on the specific
   * class. The class calls a shared code method to run the readObjectSetters.
   *
   * @param in the object input stream
   * @throws ClassNotFoundException when a nested object class can't be found
   * @throws IOException            when there is an IO problem reading the stream
   */
  private void readObject(java.io.ObjectInputStream in) throws java.io.IOException,
    ClassNotFoundException {
    logger.debug(
      "Deserializing object of class " + this.getClass().getName() + " with readObject in " +
        "AbstractItem");
    // Do the read-object deserialization.
    deserializer.doReadObject(in, this);
  }

  @Override
  public boolean equals(Object arg0) {
    IItem other = (IItem)arg0;
    return other.getPrimaryKey().equals(key);
  }

  @Override
  public int hashCode() {
    return key.hashCode();
  }

  @Override
  public int compareTo(com.poesys.db.dto.IDbDto o) {
    IItem other = (IItem)o;
    // Sort on the key. Same semantics as equals and hashCode().
    return other.getPrimaryKey().compareTo(key);
  }

  @Override
  public String getSubsystem() {
    return "com.poesys.accounting.db.transaction";
  }

  @Override
  public void markChildrenDeleted() {
    // Only process deletes if child exists.
    if (reimbursingItemsReimbursement != null) {
      for (com.poesys.db.dto.IDbDto dto : reimbursingItemsReimbursement) {
        dto.cascadeDelete();
      }
    }
    // Only process deletes if child exists.
    if (receivablesReimbursement != null) {
      for (com.poesys.db.dto.IDbDto dto : receivablesReimbursement) {
        dto.cascadeDelete();
      }
    }
  }

  @Override
  public IPrimaryKey getPrimaryKey() {
    return key;
  }

  /**
   * Nested property transactionId
   *
   * <p> Composite super-key attribute that uniquely identifies child combined with child sub-key
   * and any other parent super-keys </p>
   *
   * Added by AddGeneratedKeyProperties + AddParentKeyAttributes Class is read/write: true Class is
   * immutable: false Property is read/write: false Property is lazy: false
   */
  private java.math.BigInteger transactionId;

  /**
   * Get an object of java.math.BigInteger.
   *
   * Source: AddGeneratedKeyProperties + AddParentKeyAttributes
   *
   * @return a java.math.BigInteger
   */

  public java.math.BigInteger getTransactionId() {
    return transactionId;
  }

  /**
   * Clear the transactionId data member; override in proxy if lazily loaded, otherwise this method
   * does nothing.
   */
  public void clearTransactionId() {
    // Override in proxy if lazily loaded; otherwise does nothing
  }

  /**
   * <p> Set the transactionId. </p> <ul> <li>Read/Write DTO: true</li> <li>Immutable DTO:
   * false</li> <li>Read/Write property: false</li> <li>Immutable property: true</li> <li>Lazy
   * property: false (if true, proxy calls this method)</li> </ul> <p> Composite super-key attribute
   * that uniquely identifies child combined with child sub-key and any other parent super-keys
   * </p>
   *
   * @param transactionId the value with which to set the property
   */
  void setTransactionId(java.math.BigInteger transactionId) throws com.poesys.db
    .InvalidParametersException {
    if (transactionId == null) {
      throw new com.poesys.db.InvalidParametersException("transactionId is required");
    }

    this.transactionId = transactionId;
    setChanged();
  }

  /**
   * Nested property orderNumber
   *
   *
   *
   * Added by AddExplicitSubKeyProperties + addNaturalSubkeyOnClass Class is read/write: true Class
   * is immutable: false Property is read/write: false Property is lazy: false
   */
  private java.lang.Integer orderNumber;

  /**
   * Get an object of java.lang.Integer.
   *
   * Source: AddExplicitSubKeyProperties + addNaturalSubkeyOnClass
   *
   * @return a java.lang.Integer
   */

  public java.lang.Integer getOrderNumber() {
    return orderNumber;
  }

  /**
   * Clear the orderNumber data member; override in proxy if lazily loaded, otherwise this method
   * does nothing.
   */
  public void clearOrderNumber() {
    // Override in proxy if lazily loaded; otherwise does nothing
  }

  /**
   * <p> Set the orderNumber. </p> <ul> <li>Read/Write DTO: true</li> <li>Immutable DTO: false</li>
   * <li>Read/Write property: false</li> <li>Immutable property: false</li> <li>Lazy property: false
   * (if true, proxy calls this method)</li> </ul>
   *
   * @param orderNumber the value with which to set the property
   */
  void setOrderNumber(java.lang.Integer orderNumber) throws com.poesys.db
    .InvalidParametersException {
    if (orderNumber == null) {
      throw new com.poesys.db.InvalidParametersException("orderNumber is required");
    }

    this.orderNumber = orderNumber;
    setChanged();
  }

  /**
   * Nested property amount
   *
   * <p> the monetary amount in dollars of the transaction item </p>
   *
   * Added by AddLocalAttributeProperties Class is read/write: true Class is immutable: false
   * Property is read/write: true Property is lazy: false
   */
  private java.lang.Double amount;

  /**
   * Get an object of java.lang.Double.
   *
   * Source: AddLocalAttributeProperties
   *
   * @return a java.lang.Double
   */

  public java.lang.Double getAmount() {
    return amount;
  }

  /**
   * Clear the amount data member; override in proxy if lazily loaded, otherwise this method does
   * nothing.
   */
  public void clearAmount() {
    // Override in proxy if lazily loaded; otherwise does nothing
  }

  /**
   * <p> Set the amount. </p> <ul> <li>Read/Write DTO: true</li> <li>Immutable DTO: false</li>
   * <li>Read/Write property: true</li> <li>Immutable property: false</li> <li>Lazy property: false
   * (if true, proxy calls this method)</li> </ul> <p> the monetary amount in dollars of the
   * transaction item </p>
   *
   * @param amount the value with which to set the property
   */
  public void setAmount(java.lang.Double amount) throws com.poesys.db.InvalidParametersException {
    if (amount == null) {
      throw new com.poesys.db.InvalidParametersException("amount is required");
    }

    this.amount = amount;
    setChanged();
  }

  /**
   * Nested property debit
   *
   * <p> whether the item is a debit (true) or credit (false); default value is the debit-default
   * value of the account </p>
   *
   * Added by AddLocalAttributeProperties Class is read/write: true Class is immutable: false
   * Property is read/write: true Property is lazy: false
   */
  private java.lang.Boolean debit;

  /**
   * Get an object of java.lang.Boolean.
   *
   * Source: AddLocalAttributeProperties
   *
   * @return a java.lang.Boolean
   */

  public java.lang.Boolean getDebit() {
    return debit;
  }

  /**
   * Clear the debit data member; override in proxy if lazily loaded, otherwise this method does
   * nothing.
   */
  public void clearDebit() {
    // Override in proxy if lazily loaded; otherwise does nothing
  }

  /**
   * <p> Set the debit. </p> <ul> <li>Read/Write DTO: true</li> <li>Immutable DTO: false</li>
   * <li>Read/Write property: true</li> <li>Immutable property: false</li> <li>Lazy property: false
   * (if true, proxy calls this method)</li> </ul> <p> whether the item is a debit (true) or credit
   * (false); default value is the debit-default value of the account </p>
   *
   * @param debit the value with which to set the property
   */
  public void setDebit(java.lang.Boolean debit) throws com.poesys.db.InvalidParametersException {
    if (debit == null) {
      throw new com.poesys.db.InvalidParametersException("debit is required");
    }

    this.debit = debit;
    setChanged();
  }

  /**
   * Nested property checked
   *
   * <p> whether the value and details of the transaction item have been verified and reconciled
   * </p>
   *
   * Added by AddLocalAttributeProperties Class is read/write: true Class is immutable: false
   * Property is read/write: true Property is lazy: false
   */
  private java.lang.Boolean checked;

  /**
   * Get an object of java.lang.Boolean.
   *
   * Source: AddLocalAttributeProperties
   *
   * @return a java.lang.Boolean
   */

  public java.lang.Boolean getChecked() {
    return checked;
  }

  /**
   * Clear the checked data member; override in proxy if lazily loaded, otherwise this method does
   * nothing.
   */
  public void clearChecked() {
    // Override in proxy if lazily loaded; otherwise does nothing
  }

  /**
   * <p> Set the checked. </p> <ul> <li>Read/Write DTO: true</li> <li>Immutable DTO: false</li>
   * <li>Read/Write property: true</li> <li>Immutable property: false</li> <li>Lazy property: false
   * (if true, proxy calls this method)</li> </ul> <p> whether the value and details of the
   * transaction item have been verified and reconciled </p>
   *
   * @param checked the value with which to set the property
   */
  public void setChecked(java.lang.Boolean checked) throws com.poesys.db
    .InvalidParametersException {
    if (checked == null) {
      throw new com.poesys.db.InvalidParametersException("checked is required");
    }

    this.checked = checked;
    setChanged();
  }

  /**
   * Nested property transaction
   *
   * <p> the transaction that owns the item (the parent) </p>
   *
   * Added by AddToOneAssociationRequiredObjectProperties Class is read/write: true Class is
   * immutable: false Property is read/write: true Property is lazy: false
   */
  private com.poesys.accounting.db.transaction.ITransaction transaction;

  /**
   * Get an object of com.poesys.accounting.db.transaction.ITransaction.
   *
   * Source: AddToOneAssociationRequiredObjectProperties
   *
   * @return a com.poesys.accounting.db.transaction.ITransaction
   */

  public com.poesys.accounting.db.transaction.ITransaction getTransaction() {
    return transaction;
  }

  /**
   * Clear the transaction data member; override in proxy if lazily loaded, otherwise this method
   * does nothing.
   */
  public void clearTransaction() {
    // Override in proxy if lazily loaded; otherwise does nothing
  }

  /**
   * <p> Set the transaction. </p> <ul> <li>Read/Write DTO: true</li> <li>Immutable DTO: false</li>
   * <li>Read/Write property: true</li> <li>Immutable property: false</li> <li>Lazy property: false
   * (if true, proxy calls this method)</li> </ul> <p> the transaction that owns the item (the
   * parent) </p>
   *
   * @param transaction the value with which to set the property
   */
  public void setTransaction(com.poesys.accounting.db.transaction.ITransaction transaction)
    throws com.poesys.db.InvalidParametersException {
    if (transaction == null) {
      throw new com.poesys.db.InvalidParametersException("transaction is required");
    }

    this.transaction = transaction;
    setChanged();
  }

  /**
   * Nested property account
   *
   * <p> the account to which to associate the flow of funds for the item </p>
   *
   * Added by AddToOneAssociationRequiredObjectProperties Class is read/write: true Class is
   * immutable: false Property is read/write: true Property is lazy: false
   */
  private com.poesys.accounting.db.account.IAccount account;

  /**
   * Get an object of com.poesys.accounting.db.account.IAccount.
   *
   * Source: AddToOneAssociationRequiredObjectProperties
   *
   * @return a com.poesys.accounting.db.account.IAccount
   */

  public com.poesys.accounting.db.account.IAccount getAccount() {
    return account;
  }

  /**
   * Clear the account data member; override in proxy if lazily loaded, otherwise this method does
   * nothing.
   */
  public void clearAccount() {
    // Override in proxy if lazily loaded; otherwise does nothing
  }

  /**
   * <p> Set the account. </p> <ul> <li>Read/Write DTO: true</li> <li>Immutable DTO: false</li>
   * <li>Read/Write property: true</li> <li>Immutable property: false</li> <li>Lazy property: false
   * (if true, proxy calls this method)</li> </ul> <p> the account to which to associate the flow of
   * funds for the item </p>
   *
   * @param account the value with which to set the property
   */
  public void setAccount(com.poesys.accounting.db.account.IAccount account) throws com.poesys.db
    .InvalidParametersException {
    if (account == null) {
      throw new com.poesys.db.InvalidParametersException("account is required");
    }

    this.account = account;
    setChanged();
  }

  /**
   * Nested property accountName
   *
   * <p> Foreign key used by setter to query associated object </p>
   *
   * Added by AddExplicitSubKeyProperties + addNaturalSubkeyOnClass +
   * AddToOneAssociationAttributeProperties Class is read/write: true Class is immutable: false
   * Property is read/write: false Property is lazy: false
   */
  private java.lang.String accountName;

  /**
   * Get an object of java.lang.String.
   *
   * Source: AddExplicitSubKeyProperties + addNaturalSubkeyOnClass +
   * AddToOneAssociationAttributeProperties
   *
   * @return a java.lang.String
   */

  public java.lang.String getAccountName() {
    return accountName;
  }

  /**
   * Clear the accountName data member; override in proxy if lazily loaded, otherwise this method
   * does nothing.
   */
  public void clearAccountName() {
    // Override in proxy if lazily loaded; otherwise does nothing
  }

  /**
   * <p> Set the accountName. </p> <ul> <li>Read/Write DTO: true</li> <li>Immutable DTO: false</li>
   * <li>Read/Write property: false</li> <li>Immutable property: false</li> <li>Lazy property: false
   * (if true, proxy calls this method)</li> </ul> <p> Foreign key used by setter to query
   * associated object </p>
   *
   * @param accountName the value with which to set the property
   */
  void setAccountName(java.lang.String accountName) throws com.poesys.db
    .InvalidParametersException {
    if (accountName == null) {
      throw new com.poesys.db.InvalidParametersException("accountName is required");
    }

    this.accountName = accountName;
    setChanged();
  }

  /**
   * Nested property entityName
   *
   * <p> Foreign key used by setter to query associated object </p>
   *
   * Added by AddNaturalKeyProperties + AddParentKeyAttributes +
   * AddToOneAssociationAttributeProperties
   * Class is read/write: true Class is immutable: false Property is read/write: false Property is
   * lazy: false
   */
  private java.lang.String entityName;

  /**
   * Get an object of java.lang.String.
   *
   * Source: AddNaturalKeyProperties + AddParentKeyAttributes +
   * AddToOneAssociationAttributeProperties
   *
   * @return a java.lang.String
   */

  public java.lang.String getEntityName() {
    return entityName;
  }

  /**
   * Clear the entityName data member; override in proxy if lazily loaded, otherwise this method
   * does nothing.
   */
  public void clearEntityName() {
    // Override in proxy if lazily loaded; otherwise does nothing
  }

  /**
   * <p> Set the entityName. </p> <ul> <li>Read/Write DTO: true</li> <li>Immutable DTO: false</li>
   * <li>Read/Write property: false</li> <li>Immutable property: false</li> <li>Lazy property: false
   * (if true, proxy calls this method)</li> </ul> <p> Foreign key used by setter to query
   * associated object </p>
   *
   * @param entityName the value with which to set the property
   */
  void setEntityName(java.lang.String entityName) throws com.poesys.db.InvalidParametersException {
    if (entityName == null) {
      throw new com.poesys.db.InvalidParametersException("entityName is required");
    }

    this.entityName = entityName;
    setChanged();
  }

  /**
   * Nested property reimbursingItems
   *
   * <p> the set of reimbursed items </p>
   *
   * Added by TransformToProperty + AddToManyAssociationCollectionProperties Class is read/write:
   * true Class is immutable: false Property is read/write: true Property is lazy: true
   */
  // Doesn't serialize; package access allows proxy to set on readObject()
  transient java.util.Collection<com.poesys.accounting.db.transaction.IItem> reimbursingItems;
  // Ordered list of keys of the objects in the reimbursingItems list
  transient java.util.List<com.poesys.db.pk.IPrimaryKey> reimbursingItemKeys =
    new java.util.ArrayList<com.poesys.db.pk.IPrimaryKey>();

  /**
   * Get a collection of com.poesys.accounting.db.transaction.IItem.
   *
   * Source: TransformToProperty + AddToManyAssociationCollectionProperties
   *
   * @return a java.util.Collection<com.poesys.accounting.db.transaction.IItem>
   */

  public java.util.Collection<com.poesys.accounting.db.transaction.IItem> getReimbursingItems() {
    return reimbursingItems;
  }

  /**
   * Clear the reimbursingItems data member; override in proxy if lazily loaded, otherwise this
   * method does nothing.
   */
  public void clearReimbursingItems() {
    // Override in proxy if lazily loaded; otherwise does nothing
  }

  /**
   * <p> Set the reimbursingItems. </p> <ul> <li>Read/Write DTO: true</li> <li>Immutable DTO:
   * false</li> <li>Read/Write property: true</li> <li>Immutable property: false</li> <li>Lazy
   * property: true (if true, proxy calls this method)</li> </ul> <p> the set of reimbursed items
   * </p>
   *
   * @param reimbursingItems the value with which to set the property
   */
  public void setReimbursingItem(java.util.Collection<com.poesys.accounting.db.transaction.IItem>
                                   reimbursingItems) {
    this.reimbursingItems = reimbursingItems;
    // Add the primary keys of the new collection to the serialized key list.
    if (reimbursingItemKeys != null) {
      reimbursingItemKeys.clear();
    } else {
      // Allocate a new, empty list of primary keys.
      reimbursingItemKeys = new java.util.ArrayList<com.poesys.db.pk.IPrimaryKey>();
    }
    if (reimbursingItems != null) {
      if (reimbursingItemKeys != null) {
        reimbursingItemKeys.clear();
      } else {
        reimbursingItemKeys = new java.util.ArrayList<com.poesys.db.pk.IPrimaryKey>();
      }
      for (com.poesys.db.dto.IDbDto object : reimbursingItems) {
        reimbursingItemKeys.add(object.getPrimaryKey());
      }
    }
    setChanged();
  }

  /**
   * Nested property receivables
   *
   * <p> the set of receivable items </p>
   *
   * Added by TransformToProperty + AddToManyAssociationCollectionProperties Class is read/write:
   * true Class is immutable: false Property is read/write: true Property is lazy: true
   */
  // Doesn't serialize; package access allows proxy to set on readObject()
  transient java.util.Collection<com.poesys.accounting.db.transaction.IItem> receivables;
  // Ordered list of keys of the objects in the receivables list
  transient java.util.List<com.poesys.db.pk.IPrimaryKey> receivableKeys =
    new java.util.ArrayList<com.poesys.db.pk.IPrimaryKey>();

  /**
   * Get a collection of com.poesys.accounting.db.transaction.IItem.
   *
   * Source: TransformToProperty + AddToManyAssociationCollectionProperties
   *
   * @return a java.util.Collection<com.poesys.accounting.db.transaction.IItem>
   */

  public java.util.Collection<com.poesys.accounting.db.transaction.IItem> getReceivables() {
    return receivables;
  }

  /**
   * Clear the receivables data member; override in proxy if lazily loaded, otherwise this method
   * does nothing.
   */
  public void clearReceivables() {
    // Override in proxy if lazily loaded; otherwise does nothing
  }

  /**
   * <p> Set the receivables. </p> <ul> <li>Read/Write DTO: true</li> <li>Immutable DTO: false</li>
   * <li>Read/Write property: true</li> <li>Immutable property: false</li> <li>Lazy property: true
   * (if true, proxy calls this method)</li> </ul> <p> the set of receivable items </p>
   *
   * @param receivables the value with which to set the property
   */
  public void setReceivable(java.util.Collection<com.poesys.accounting.db.transaction.IItem>
                              receivables) {
    this.receivables = receivables;
    // Add the primary keys of the new collection to the serialized key list.
    if (receivableKeys != null) {
      receivableKeys.clear();
    } else {
      // Allocate a new, empty list of primary keys.
      receivableKeys = new java.util.ArrayList<com.poesys.db.pk.IPrimaryKey>();
    }
    if (receivables != null) {
      if (receivableKeys != null) {
        receivableKeys.clear();
      } else {
        receivableKeys = new java.util.ArrayList<com.poesys.db.pk.IPrimaryKey>();
      }
      for (com.poesys.db.dto.IDbDto object : receivables) {
        receivableKeys.add(object.getPrimaryKey());
      }
    }
    setChanged();
  }

  /**
   * Nested property reimbursingItemsReimbursement
   *
   * <p> Collection of association class objects (not the associated objects) </p>
   *
   * Added by AddAssociationClassCollectionProperties Class is read/write: true Class is immutable:
   * false Property is read/write: true Property is lazy: true
   */
  // Doesn't serialize; package access allows proxy to set on readObject()
  transient java.util.Collection<com.poesys.accounting.db.transaction.IReimbursement>
    reimbursingItemsReimbursement;
  // Ordered list of keys of the objects in the reimbursingItemsReimbursement list
  transient java.util.List<com.poesys.db.pk.IPrimaryKey> reimbursingItemsReimbursementKeys =
    new java.util.ArrayList<com.poesys.db.pk.IPrimaryKey>();

  /**
   * Get a collection of com.poesys.accounting.db.transaction.IReimbursement.
   *
   * Source: AddAssociationClassCollectionProperties
   *
   * @return a java.util.Collection<com.poesys.accounting.db.transaction.IReimbursement>
   */

  public java.util.Collection<com.poesys.accounting.db.transaction.IReimbursement>
  getReimbursingItemsReimbursement() {
    return reimbursingItemsReimbursement;
  }

  /**
   * Clear the reimbursingItemsReimbursement data member; override in proxy if lazily loaded,
   * otherwise this method does nothing.
   */
  public void clearReimbursingItemsReimbursement() {
    // Override in proxy if lazily loaded; otherwise does nothing
  }

  /**
   * <p> Set the reimbursingItemsReimbursement. </p> <ul> <li>Read/Write DTO: true</li>
   * <li>Immutable DTO: false</li> <li>Read/Write property: true</li> <li>Immutable property:
   * false</li> <li>Lazy property: true (if true, proxy calls this method)</li> </ul> <p> Collection
   * of association class objects (not the associated objects) </p>
   *
   * @param reimbursingItemsReimbursement the value with which to set the property
   */
  public void setReimbursingItemsReimbursement(java.util.Collection<com.poesys.accounting.db
    .transaction.IReimbursement> reimbursingItemsReimbursement) throws com.poesys.db
    .InvalidParametersException {
    if (reimbursingItemsReimbursement == null) {
      throw new com.poesys.db.InvalidParametersException(
        "reimbursingItemsReimbursement is required");
    }

    this.reimbursingItemsReimbursement = reimbursingItemsReimbursement;
    // Add the primary keys of the new collection to the serialized key list.
    if (reimbursingItemsReimbursementKeys != null) {
      reimbursingItemsReimbursementKeys.clear();
    } else {
      // Allocate a new, empty list of primary keys.
      reimbursingItemsReimbursementKeys = new java.util.ArrayList<com.poesys.db.pk.IPrimaryKey>();
    }
    if (reimbursingItemsReimbursement != null) {
      if (reimbursingItemsReimbursementKeys != null) {
        reimbursingItemsReimbursementKeys.clear();
      } else {
        reimbursingItemsReimbursementKeys = new java.util.ArrayList<com.poesys.db.pk.IPrimaryKey>();
      }
      for (com.poesys.db.dto.IDbDto object : reimbursingItemsReimbursement) {
        reimbursingItemsReimbursementKeys.add(object.getPrimaryKey());
      }
    }
    setChanged();
  }

  /**
   * Nested property receivablesReimbursement
   *
   * <p> Collection of association class objects (not the associated objects) </p>
   *
   * Added by AddAssociationClassCollectionProperties Class is read/write: true Class is immutable:
   * false Property is read/write: true Property is lazy: true
   */
  // Doesn't serialize; package access allows proxy to set on readObject()
  transient java.util.Collection<com.poesys.accounting.db.transaction.IReimbursement>
    receivablesReimbursement;
  // Ordered list of keys of the objects in the receivablesReimbursement list
  transient java.util.List<com.poesys.db.pk.IPrimaryKey> receivablesReimbursementKeys =
    new java.util.ArrayList<com.poesys.db.pk.IPrimaryKey>();

  /**
   * Get a collection of com.poesys.accounting.db.transaction.IReimbursement.
   *
   * Source: AddAssociationClassCollectionProperties
   *
   * @return a java.util.Collection<com.poesys.accounting.db.transaction.IReimbursement>
   */

  public java.util.Collection<com.poesys.accounting.db.transaction.IReimbursement>
  getReceivablesReimbursement() {
    return receivablesReimbursement;
  }

  /**
   * Clear the receivablesReimbursement data member; override in proxy if lazily loaded, otherwise
   * this method does nothing.
   */
  public void clearReceivablesReimbursement() {
    // Override in proxy if lazily loaded; otherwise does nothing
  }

  /**
   * <p> Set the receivablesReimbursement. </p> <ul> <li>Read/Write DTO: true</li> <li>Immutable
   * DTO: false</li> <li>Read/Write property: true</li> <li>Immutable property: false</li> <li>Lazy
   * property: true (if true, proxy calls this method)</li> </ul> <p> Collection of association
   * class objects (not the associated objects) </p>
   *
   * @param receivablesReimbursement the value with which to set the property
   */
  public void setReceivablesReimbursement(java.util.Collection<com.poesys.accounting.db
    .transaction.IReimbursement> receivablesReimbursement) throws com.poesys.db
    .InvalidParametersException {
    if (receivablesReimbursement == null) {
      throw new com.poesys.db.InvalidParametersException("receivablesReimbursement is required");
    }

    this.receivablesReimbursement = receivablesReimbursement;
    // Add the primary keys of the new collection to the serialized key list.
    if (receivablesReimbursementKeys != null) {
      receivablesReimbursementKeys.clear();
    } else {
      // Allocate a new, empty list of primary keys.
      receivablesReimbursementKeys = new java.util.ArrayList<com.poesys.db.pk.IPrimaryKey>();
    }
    if (receivablesReimbursement != null) {
      if (receivablesReimbursementKeys != null) {
        receivablesReimbursementKeys.clear();
      } else {
        receivablesReimbursementKeys = new java.util.ArrayList<com.poesys.db.pk.IPrimaryKey>();
      }
      for (com.poesys.db.dto.IDbDto object : receivablesReimbursement) {
        receivablesReimbursementKeys.add(object.getPrimaryKey());
      }
    }
    setChanged();
  }

  @Override
  public void update(com.poesys.db.dto.ISubject subject, com.poesys.db.dao.DataEvent event) {

    // Clean up reimbursingItemsReimbursement.
    if (subject != null && subject instanceof com.poesys.accounting.db.transaction.IReimbursement
      && event == com.poesys.db.dao.DataEvent.DELETE && reimbursingItemsReimbursement != null) {
      // Delete to-many reimbursingItemsReimbursement child from collection
      reimbursingItemsReimbursement.remove(subject);
      subject.detach(this, com.poesys.db.dao.DataEvent.MARKED_DELETED);
      subject.detach(this, com.poesys.db.dao.DataEvent.DELETE);
    }

    // Clean up receivablesReimbursement.
    if (subject != null && subject instanceof com.poesys.accounting.db.transaction.IReimbursement
      && event == com.poesys.db.dao.DataEvent.DELETE && receivablesReimbursement != null) {
      // Delete to-many receivablesReimbursement child from collection
      receivablesReimbursement.remove(subject);
      subject.detach(this, com.poesys.db.dao.DataEvent.MARKED_DELETED);
      subject.detach(this, com.poesys.db.dao.DataEvent.DELETE);
    }

    // Cascade delete to reimbursingItemsReimbursement.
    if (event == com.poesys.db.dao.DataEvent.MARKED_DELETED && reimbursingItemsReimbursement !=
      null) {
      // Mark reimbursingItemsReimbursement association object cascade-deleted.
      outer:
      for (com.poesys.accounting.db.transaction.IReimbursement value :
        reimbursingItemsReimbursement) {
        com.poesys.db.pk.AssociationPrimaryKey keys =
          (com.poesys.db.pk.AssociationPrimaryKey)value.getPrimaryKey();
        for (com.poesys.db.pk.IPrimaryKey key : keys.getKeyListCopy()) {
          if (key.equals(subject.getPrimaryKey())) {
            value.cascadeDelete();
            break outer;
          }
        }
      }
    }

    // Cascade delete to receivablesReimbursement.
    if (event == com.poesys.db.dao.DataEvent.MARKED_DELETED && receivablesReimbursement != null) {
      // Mark receivablesReimbursement association object cascade-deleted.
      outer:
      for (com.poesys.accounting.db.transaction.IReimbursement value : receivablesReimbursement) {
        com.poesys.db.pk.AssociationPrimaryKey keys =
          (com.poesys.db.pk.AssociationPrimaryKey)value.getPrimaryKey();
        for (com.poesys.db.pk.IPrimaryKey key : keys.getKeyListCopy()) {
          if (key.equals(subject.getPrimaryKey())) {
            value.cascadeDelete();
            break outer;
          }
        }
      }
    }
  }

  /**
   * Create the inserters for the Item and its superclasses.
   */
  private void createInserters() {
    com.poesys.db.dao.IDaoManager manager =
      com.poesys.db.dao.DaoManagerFactory.getManager(getSubsystem());
    final com.poesys.db.dao.IDaoFactory<com.poesys.accounting.db.transaction.IItem> itemFactory =
      manager.getFactory("com.poesys.accounting.db.transaction.Item", getSubsystem(), 2147483647);
    com.poesys.db.dao.insert.IInsertSql<IItem> sql =
      new com.poesys.accounting.db.transaction.sql.InsertItem();
    com.poesys.db.dao.insert.IInsert<IItem> inserter = itemFactory.getInsert(sql, true);
    inserters.add(inserter);
  }
}