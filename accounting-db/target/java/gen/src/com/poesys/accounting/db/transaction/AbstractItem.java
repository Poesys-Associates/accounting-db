/**
 * Copyright 2016 Poesys Associates. All rights reserved.
 */
// Generated by AndroMDA Poesys/DB cartridge: DO NOT EDIT DIRECTLY.
// Template: AbstractDbDto.vsl

package com.poesys.accounting.db.transaction;


import org.apache.log4j.Logger;

import com.poesys.db.pk.IPrimaryKey;

import com.poesys.db.dto.AbstractDto;


/**
 * <p>
 * A data-access layer data-transfer object for the Item. This class is an
 * abstract class that contains AndroMDA generated code; change nothing in this
 * class. Instead, override any methods in the concrete subclass generated in
 * the same package. AndroMDA will overwrite this class each time you run it but
 * will never overwrite the concrete subclass.
 * </p>
 * <p>
 * A specific amount of value associated with a specific account within a
 * transaction parent; the item debits and credits must cancel each other out
 * for the set of all items belonging to the transaction (the transaction must
 * "balance"); the transaction orders the set of items according to an integer
 * order number, which is part of the primary key
 * </p>
 * <p>
 * Stereotypes:
 * </p>
 * <ul>
 * <li>CompositeKey</li>
 * <li>Persistent</li>
 * </ul>
 * <p>
 * Class is read/write: true
 * </p>
 *
 * @author Poesys/DB Cartridge
 */
public abstract class AbstractItem extends AbstractDto implements IItem {
  /** Default serial version UID for the Serializable DTO */
  private static final long serialVersionUID = 1L;

  /** Logger for this class */
  private static final Logger logger = Logger.getLogger(AbstractItem.class);

  /** the deserializer used by the readObject method */
  private static final com.poesys.db.dto.Deserializer<AbstractItem> deserializer =
    new com.poesys.db.dto.Deserializer<AbstractItem>();

  // Setter strategy nested classes for single-object associations

  /**
   * Nested class that manages the transaction association data
   *
   * Source: AddToOneAssociationRequiredObjectProperties
   *
   * @author Poesys/DB Cartridge
   */
  private class QueryTransactionSetter
      extends
      com.poesys.db.dto.AbstractObjectSetter<com.poesys.accounting.db.transaction.ITransaction> {
    private static final long serialVersionUID = 1L;

    /**
     * Create a QueryTransactionSetter object.
     */
    public QueryTransactionSetter() {
      super("com.poesys.accounting.db.transaction", 2147483647);
    }

    @Override
    protected String getClassName() {
      return com.poesys.accounting.db.transaction.Transaction.class.getName();
    }

    @Override
    protected IPrimaryKey getKey() {
      return transactionKey;
    }

    @Override
    protected com.poesys.db.dao.query.IKeyQuerySql<com.poesys.accounting.db.transaction.ITransaction> getSql() {
      return new com.poesys.accounting.db.transaction.sql.QueryTransaction();
    }

    @Override
    protected void set(com.poesys.accounting.db.transaction.ITransaction dto) {
      // No status change, this is just filling in the object data.
      transaction = dto;
    }

    @Override
    public boolean isSet() {
      // Object is set if the associated transaction is not null
      return transaction != null;
    }
  }

  /**
   * Post-process setter for post-processing nested object property transaction.
   */
  private class PostProcessTransactionSetter extends
      com.poesys.db.dto.AbstractPostProcessSetter {
    // Property transaction source: AddToOneAssociationRequiredObjectProperties
    private static final long serialVersionUID = 1L;

    /**
     * Create a PostProcessTransactionSetter object.
     */
    public PostProcessTransactionSetter() {
      super("com.poesys.accounting.db.transaction", 2147483647);
    }

    @Override
    protected String getClassName() {
      return com.poesys.accounting.db.transaction.Transaction.class.getName();
    }

    @SuppressWarnings("unchecked")
    @Override
    protected java.util.Collection<com.poesys.db.dto.IDbDto> getDtos() {
      java.util.ArrayList<com.poesys.db.dto.IDbDto> array =
        new java.util.ArrayList<com.poesys.db.dto.IDbDto>(1);
      if (transaction != null) {
        array.add(transaction);
      }
      java.util.Collection<? extends com.poesys.db.dto.IDbDto> dtos = array;
      return (java.util.Collection<com.poesys.db.dto.IDbDto>)dtos;
    }
  }

  /**
   * Insert setter for inserting nested object property transaction.
   */
  private class InsertTransactionSetter extends
      com.poesys.db.dto.AbstractInsertSetter {
    // Property transaction source: AddToOneAssociationRequiredObjectProperties
    private static final long serialVersionUID = 1L;

    /**
     * Create an InsertTransactionSetter object.
     */
    public InsertTransactionSetter() {
      super("com.poesys.accounting.db.transaction", 2147483647);
    }

    @Override
    protected String getClassName() {
      return com.poesys.accounting.db.transaction.Transaction.class.getName();
    }

    @SuppressWarnings("unchecked")
    @Override
    protected java.util.Collection<com.poesys.db.dto.IDbDto> getDtos() {
      java.util.ArrayList<com.poesys.db.dto.IDbDto> array =
        new java.util.ArrayList<com.poesys.db.dto.IDbDto>(1);
      array.add(transaction);
      java.util.Collection<? extends com.poesys.db.dto.IDbDto> dtos = array;
      return (java.util.Collection<com.poesys.db.dto.IDbDto>)dtos;
    }

    @Override
    protected boolean createKey() {
      // Key type: SequenceKey
      return true;
    }
  }

  /**
   * Setter for processing added transaction, updated transaction, and deleted
   * transaction.
   */

  private class UpdateTransactionSetter
      extends
      com.poesys.db.dto.AbstractProcessNestedObject<com.poesys.accounting.db.transaction.ITransaction> {
    private static final long serialVersionUID = 1L;

    /**
     * Create an UpdateTransactionSetter object.
     */
    public UpdateTransactionSetter() {
      super("com.poesys.accounting.db.transaction", 2147483647);
    }

    @Override
    protected void doChanged(com.poesys.accounting.db.transaction.ITransaction dto) {
      // transaction source: AddToOneAssociationRequiredObjectProperties
      // Immutable: false
      com.poesys.db.dao.IDaoManager manager =
        com.poesys.db.dao.DaoManagerFactory.getManager(subsystem);
      com.poesys.db.dao.IDaoFactory<com.poesys.accounting.db.transaction.ITransaction> factory =
        manager.getFactory(com.poesys.accounting.db.transaction.Transaction.class.getName(),
                           subsystem,
                           2147483647);
      com.poesys.db.dao.update.IUpdate<com.poesys.accounting.db.transaction.ITransaction> updater =
        factory.getUpdate(new com.poesys.accounting.db.transaction.sql.UpdateTransaction());

      updater.update(dto);
      // Complete the update by setting the DTO to EXISTING status.
      dto.setExisting();
    }

    @Override
    protected void doDeleted(com.poesys.accounting.db.transaction.ITransaction dto) {
      com.poesys.db.dao.IDaoManager manager =
        com.poesys.db.dao.DaoManagerFactory.getManager(subsystem);
      com.poesys.db.dao.IDaoFactory<com.poesys.accounting.db.transaction.ITransaction> factory =
        manager.getFactory(com.poesys.accounting.db.transaction.Transaction.class.getName(),
                           subsystem,
                           2147483647);
      com.poesys.db.dao.delete.IDelete<com.poesys.accounting.db.transaction.ITransaction> dao =
        factory.getDelete(new com.poesys.accounting.db.transaction.sql.DeleteTransaction());
      dao.delete(dto);
    }

    @Override
    protected void doNew(com.poesys.accounting.db.transaction.ITransaction dto) {
      com.poesys.db.dao.IDaoManager manager =
        com.poesys.db.dao.DaoManagerFactory.getManager(subsystem);
      com.poesys.db.dao.IDaoFactory<com.poesys.accounting.db.transaction.ITransaction> factory =
        manager.getFactory(com.poesys.accounting.db.transaction.Transaction.class.getName(),
                           subsystem,
                           2147483647);
      com.poesys.db.dao.insert.IInsert<com.poesys.accounting.db.transaction.ITransaction> inserter =
        factory.getInsert(new com.poesys.accounting.db.transaction.sql.InsertTransaction(),
                          createKey());

      // Insert the superclass objects from the root down. Suppress nested
      // inserts for the superclasses, wait until the concrete class. Also set
      // pre-insert suppression off to have the root insert linked, to-one class
      // objects.
      dto.setSuppressNestedInserts(true);
      dto.setSuppressNestedPreInserts(false);

      // Suppress inserts in concrete class.
      dto.setSuppressNestedPreInserts(true);

      // Insert the object of the current class after enabling nested inserts,
      // which will allow connecting up linked objects to any of the inserted
      // classes.
      dto.setSuppressNestedInserts(false);
      inserter.insert(dto);
    }

    @Override
    protected com.poesys.accounting.db.transaction.ITransaction getDto() {
      return transaction;
    }

    @Override
    protected String getClassName() {
      return com.poesys.accounting.db.transaction.Transaction.class.getName();
    }

    @Override
    protected boolean createKey() {
      // Key type: SequenceKey
      return true;
    }
  }

  /**
   * Foreign key object used by QueryTransactionSetter nested class to query
   * object
   */
  private IPrimaryKey transactionKey;

  /**
   * Set the foreign key transactionKey. This has package access to enable the
   * subsystem factory getData method to call this method to set the key by
   * creating it from the queried result set.
   *
   * @param transactionKey the foreign key
   */
  void setTransactionKey(IPrimaryKey transactionKey) {
    this.transactionKey = transactionKey;
  }

  /**
   * Nested class that manages the account association data
   *
   * Source: AddToOneAssociationRequiredObjectProperties
   *
   * @author Poesys/DB Cartridge
   */
  private class QueryAccountSetter
      extends
      com.poesys.db.dto.AbstractObjectSetter<com.poesys.accounting.db.account.IAccount> {
    private static final long serialVersionUID = 1L;

    /**
     * Create a QueryAccountSetter object.
     */
    public QueryAccountSetter() {
      super("com.poesys.accounting.db.account", 2147483647);
    }

    @Override
    protected String getClassName() {
      return com.poesys.accounting.db.account.Account.class.getName();
    }

    @Override
    protected IPrimaryKey getKey() {
      return accountKey;
    }

    @Override
    protected com.poesys.db.dao.query.IKeyQuerySql<com.poesys.accounting.db.account.IAccount> getSql() {
      return new com.poesys.accounting.db.account.sql.QueryAccount();
    }

    @Override
    protected void set(com.poesys.accounting.db.account.IAccount dto) {
      // No status change, this is just filling in the object data.
      account = dto;
    }

    @Override
    public boolean isSet() {
      // Object is set if the associated account is not null
      return account != null;
    }
  }

  /**
   * Post-process setter for post-processing nested object property account.
   */
  private class PostProcessAccountSetter extends
      com.poesys.db.dto.AbstractPostProcessSetter {
    // Property account source: AddToOneAssociationRequiredObjectProperties
    private static final long serialVersionUID = 1L;

    /**
     * Create a PostProcessAccountSetter object.
     */
    public PostProcessAccountSetter() {
      super("com.poesys.accounting.db.account", 2147483647);
    }

    @Override
    protected String getClassName() {
      return com.poesys.accounting.db.account.Account.class.getName();
    }

    @SuppressWarnings("unchecked")
    @Override
    protected java.util.Collection<com.poesys.db.dto.IDbDto> getDtos() {
      java.util.ArrayList<com.poesys.db.dto.IDbDto> array =
        new java.util.ArrayList<com.poesys.db.dto.IDbDto>(1);
      if (account != null) {
        array.add(account);
      }
      java.util.Collection<? extends com.poesys.db.dto.IDbDto> dtos = array;
      return (java.util.Collection<com.poesys.db.dto.IDbDto>)dtos;
    }
  }

  /**
   * Insert setter for inserting nested object property account.
   */
  private class InsertAccountSetter extends
      com.poesys.db.dto.AbstractInsertSetter {
    // Property account source: AddToOneAssociationRequiredObjectProperties
    private static final long serialVersionUID = 1L;

    /**
     * Create an InsertAccountSetter object.
     */
    public InsertAccountSetter() {
      super("com.poesys.accounting.db.account", 2147483647);
    }

    @Override
    protected String getClassName() {
      return com.poesys.accounting.db.account.Account.class.getName();
    }

    @SuppressWarnings("unchecked")
    @Override
    protected java.util.Collection<com.poesys.db.dto.IDbDto> getDtos() {
      java.util.ArrayList<com.poesys.db.dto.IDbDto> array =
        new java.util.ArrayList<com.poesys.db.dto.IDbDto>(1);
      array.add(account);
      java.util.Collection<? extends com.poesys.db.dto.IDbDto> dtos = array;
      return (java.util.Collection<com.poesys.db.dto.IDbDto>)dtos;
    }

    @Override
    protected boolean createKey() {
      // Key type: CompositeKey
      return true;
    }
  }

  /**
   * Setter for processing added account, updated account, and deleted account.
   */

  private class UpdateAccountSetter
      extends
      com.poesys.db.dto.AbstractProcessNestedObject<com.poesys.accounting.db.account.IAccount> {
    private static final long serialVersionUID = 1L;

    /**
     * Create an UpdateAccountSetter object.
     */
    public UpdateAccountSetter() {
      super("com.poesys.accounting.db.account", 2147483647);
    }

    @Override
    protected void doChanged(com.poesys.accounting.db.account.IAccount dto) {
      // account source: AddToOneAssociationRequiredObjectProperties
      // Immutable: false
      com.poesys.db.dao.IDaoManager manager =
        com.poesys.db.dao.DaoManagerFactory.getManager(subsystem);
      com.poesys.db.dao.IDaoFactory<com.poesys.accounting.db.account.IAccount> factory =
        manager.getFactory(com.poesys.accounting.db.account.Account.class.getName(),
                           subsystem,
                           2147483647);
      com.poesys.db.dao.update.IUpdate<com.poesys.accounting.db.account.IAccount> updater =
        factory.getUpdate(new com.poesys.accounting.db.account.sql.UpdateAccount());

      updater.update(dto);
      // Complete the update by setting the DTO to EXISTING status.
      dto.setExisting();
    }

    @Override
    protected void doDeleted(com.poesys.accounting.db.account.IAccount dto) {
      com.poesys.db.dao.IDaoManager manager =
        com.poesys.db.dao.DaoManagerFactory.getManager(subsystem);
      com.poesys.db.dao.IDaoFactory<com.poesys.accounting.db.account.IAccount> factory =
        manager.getFactory(com.poesys.accounting.db.account.Account.class.getName(),
                           subsystem,
                           2147483647);
      com.poesys.db.dao.delete.IDelete<com.poesys.accounting.db.account.IAccount> dao =
        factory.getDelete(new com.poesys.accounting.db.account.sql.DeleteAccount());
      dao.delete(dto);
    }

    @Override
    protected void doNew(com.poesys.accounting.db.account.IAccount dto) {
      com.poesys.db.dao.IDaoManager manager =
        com.poesys.db.dao.DaoManagerFactory.getManager(subsystem);
      com.poesys.db.dao.IDaoFactory<com.poesys.accounting.db.account.IAccount> factory =
        manager.getFactory(com.poesys.accounting.db.account.Account.class.getName(),
                           subsystem,
                           2147483647);
      com.poesys.db.dao.insert.IInsert<com.poesys.accounting.db.account.IAccount> inserter =
        factory.getInsert(new com.poesys.accounting.db.account.sql.InsertAccount(),
                          createKey());

      // Insert the superclass objects from the root down. Suppress nested
      // inserts for the superclasses, wait until the concrete class. Also set
      // pre-insert suppression off to have the root insert linked, to-one class
      // objects.
      dto.setSuppressNestedInserts(true);
      dto.setSuppressNestedPreInserts(false);

      // Suppress inserts in concrete class.
      dto.setSuppressNestedPreInserts(true);

      // Insert the object of the current class after enabling nested inserts,
      // which will allow connecting up linked objects to any of the inserted
      // classes.
      dto.setSuppressNestedInserts(false);
      inserter.insert(dto);
    }

    @Override
    protected com.poesys.accounting.db.account.IAccount getDto() {
      return account;
    }

    @Override
    protected String getClassName() {
      return com.poesys.accounting.db.account.Account.class.getName();
    }

    @Override
    protected boolean createKey() {
      // Key type: CompositeKey
      return true;
    }
  }

  /**
   * Foreign key object used by QueryAccountSetter nested class to query object
   */
  private IPrimaryKey accountKey;

  /**
   * Set the foreign key accountKey. This has package access to enable the
   * subsystem factory getData method to call this method to set the key by
   * creating it from the queried result set.
   *
   * @param accountKey the foreign key
   */
  void setAccountKey(IPrimaryKey accountKey) {
    this.accountKey = accountKey;
  }

  // Setter strategy nested classes for multiple-object associations

  /**
   * Post-processing setter for post-processing nested to-many association
   * reimbursedItem.
   */
  private class PostProcessReimbursingItemsSetter extends
      com.poesys.db.dto.AbstractPostProcessSetter {
    private static final long serialVersionUID = 1L;

    // Association reimbursingItems source: TransformToProperty +
    // AddToManyAssociationCollectionProperties

    /**
     * Create an PostProcessreimbursingItemsSetter object.
     */
    public PostProcessReimbursingItemsSetter() {
      super("com.poesys.accounting.db.transaction", 2147483647);
    }

    @Override
    protected String getClassName() {
      return com.poesys.accounting.db.transaction.Item.class.getName();
    }

    @SuppressWarnings("unchecked")
    @Override
    protected java.util.Collection<com.poesys.db.dto.IDbDto> getDtos() {
      java.util.Collection<? extends com.poesys.db.dto.IDbDto> dtos =
        reimbursingItems;
      return (java.util.Collection<com.poesys.db.dto.IDbDto>)dtos;
    }
  }

  /**
   * Insert setter for inserting nested to-many association reimbursedItem.
   *
   * @see com.poesys.accounting.db.transaction.sql.InsertItem
   */
  private class InsertReimbursingItemsSetter extends
      com.poesys.db.dto.AbstractInsertSetter {
    private static final long serialVersionUID = 1L;

    // Association reimbursingItems source: TransformToProperty +
    // AddToManyAssociationCollectionProperties

    /**
     * Create an InsertreimbursingItemsSetter object.
     */
    public InsertReimbursingItemsSetter() {
      super("com.poesys.accounting.db.transaction", 2147483647);
    }

    @Override
    protected String getClassName() {
      return com.poesys.accounting.db.transaction.Item.class.getName();
    }

    @SuppressWarnings("unchecked")
    @Override
    protected java.util.Collection<com.poesys.db.dto.IDbDto> getDtos() {
      java.util.Collection<? extends com.poesys.db.dto.IDbDto> dtos =
        reimbursingItems;
      return (java.util.Collection<com.poesys.db.dto.IDbDto>)dtos;
    }

    @Override
    protected boolean createKey() {
      return true;
    }
  }

  /**
   * Setter for processing added reimbursedItem, updated reimbursedItem, and
   * deleted reimbursedItem.
   */

  private class UpdateReimbursingItemsSetter
      extends
      com.poesys.db.dto.AbstractProcessNestedObjects<com.poesys.accounting.db.transaction.IItem, java.util.Collection<com.poesys.accounting.db.transaction.IItem>> {
    private static final long serialVersionUID = 1L;
    private static final int BATCH_SIZE = 100;

    /**
     * Create an UpdateReimbursingItemsSetter object.
     */
    public UpdateReimbursingItemsSetter() {
      super("com.poesys.accounting.db.transaction", 2147483647);
    }

    @Override
    protected void doChanged(java.util.Collection<com.poesys.accounting.db.transaction.IItem> dtos) {
      // reimbursingItems source: TransformToProperty +
      // AddToManyAssociationCollectionProperties
      // Immutable: false
      com.poesys.db.dao.IDaoManager manager =
        com.poesys.db.dao.DaoManagerFactory.getManager(subsystem);

      com.poesys.db.dao.IDaoFactory<com.poesys.accounting.db.transaction.IItem> factory =
        manager.getFactory(com.poesys.accounting.db.transaction.Item.class.getName(),
                           subsystem,
                           2147483647);
      com.poesys.db.dao.update.IUpdateBatch<com.poesys.accounting.db.transaction.IItem> updater =
        factory.getUpdateBatch(new com.poesys.accounting.db.transaction.sql.UpdateItem());

      // Update the object of the leaf class.
      updater.update(dtos, dtos.size() / 2);
      // Complete the update by setting the DTOs to EXISTING status.
      for (com.poesys.db.dto.IDbDto dto : dtos) {
        if (dto.getStatus() == Status.CHANGED) {
          dto.setExisting();
        }
      }
    }

    @Override
    protected void doDeleted(java.util.Collection<com.poesys.accounting.db.transaction.IItem> dtos) {
      com.poesys.db.dao.IDaoManager manager =
        com.poesys.db.dao.DaoManagerFactory.getManager(subsystem);
      com.poesys.db.dao.IDaoFactory<com.poesys.accounting.db.transaction.IItem> factory =
        manager.getFactory(com.poesys.accounting.db.transaction.Item.class.getName(),
                           subsystem,
                           2147483647);
      com.poesys.db.dao.delete.IDeleteBatch<com.poesys.accounting.db.transaction.IItem> dao =
        factory.getDeleteBatch(new com.poesys.accounting.db.transaction.sql.DeleteItem());
      dao.delete(dtos, BATCH_SIZE);
    }

    @Override
    protected void doNew(java.util.Collection<com.poesys.accounting.db.transaction.IItem> dtos) {
      com.poesys.db.dao.IDaoManager manager =
        com.poesys.db.dao.DaoManagerFactory.getManager(subsystem);

      com.poesys.db.dao.IDaoFactory<com.poesys.accounting.db.transaction.IItem> factory =
        manager.getFactory(com.poesys.accounting.db.transaction.Item.class.getName(),
                           subsystem,
                           2147483647);
      com.poesys.db.dao.insert.IInsertBatch<com.poesys.accounting.db.transaction.IItem> inserter =
        factory.getInsertBatch(new com.poesys.accounting.db.transaction.sql.InsertItem());

      // Insert the object of the current class after enabling nested inserts,
      // which will allow connecting up linked objects to any of the inserted
      // classes.
      for (com.poesys.db.dto.IDbDto dto : dtos) {
        dto.setSuppressNestedInserts(false);
      }
      inserter.insert(dtos, dtos.size() / 2);
    }

    @Override
    protected java.util.Collection<com.poesys.accounting.db.transaction.IItem> getDtos() {
      return reimbursingItems;
    }

    @Override
    protected String getClassName() {
      return com.poesys.accounting.db.transaction.Item.class.getName();
    }
  }

  @Override
  public void addReimbursingItem(com.poesys.accounting.db.transaction.IItem object) {
    if (reimbursingItems == null) {
      // Association not yet created, create it.
      reimbursingItems =
        new java.util.ArrayList<com.poesys.accounting.db.transaction.IItem>();
    }
    reimbursingItems.add(object);
    // Add the primary key to the primary key array.
    if (reimbursedItemKeys != null) {
      reimbursedItemKeys.clear();
    } else {
      reimbursedItemKeys =
        new java.util.ArrayList<com.poesys.db.pk.IPrimaryKey>();
    }
    reimbursedItemKeys.add(object.getPrimaryKey());
  }

  /**
   * Post-processing setter for post-processing nested to-many association
   * receivables.
   */
  private class PostProcessReceivablesSetter extends
      com.poesys.db.dto.AbstractPostProcessSetter {
    private static final long serialVersionUID = 1L;

    // Association receivables source: TransformToProperty +
    // AddToManyAssociationCollectionProperties

    /**
     * Create an PostProcessReceivablesSetter object.
     */
    public PostProcessReceivablesSetter() {
      super("com.poesys.accounting.db.transaction", 2147483647);
    }

    @Override
    protected String getClassName() {
      return com.poesys.accounting.db.transaction.Item.class.getName();
    }

    @SuppressWarnings("unchecked")
    @Override
    protected java.util.Collection<com.poesys.db.dto.IDbDto> getDtos() {
      java.util.Collection<? extends com.poesys.db.dto.IDbDto> dtos =
        receivables;
      return (java.util.Collection<com.poesys.db.dto.IDbDto>)dtos;
    }
  }

  /**
   * Insert setter for inserting nested to-many association receivables.
   *
   * @see com.poesys.accounting.db.transaction.sql.InsertItem
   */
  private class InsertReceivablesSetter extends
      com.poesys.db.dto.AbstractInsertSetter {
    private static final long serialVersionUID = 1L;

    // Association receivables source: TransformToProperty +
    // AddToManyAssociationCollectionProperties

    /**
     * Create an InsertReceivablesSetter object.
     */
    public InsertReceivablesSetter() {
      super("com.poesys.accounting.db.transaction", 2147483647);
    }

    @Override
    protected String getClassName() {
      return com.poesys.accounting.db.transaction.Item.class.getName();
    }

    @SuppressWarnings("unchecked")
    @Override
    protected java.util.Collection<com.poesys.db.dto.IDbDto> getDtos() {
      java.util.Collection<? extends com.poesys.db.dto.IDbDto> dtos =
        receivables;
      return (java.util.Collection<com.poesys.db.dto.IDbDto>)dtos;
    }

    @Override
    protected boolean createKey() {
      return true;
    }
  }

  /**
   * Setter for processing added receivable, updated receivable, and deleted
   * receivables.
   */

  private class UpdateReceivablesSetter
      extends
      com.poesys.db.dto.AbstractProcessNestedObjects<com.poesys.accounting.db.transaction.IItem, java.util.Collection<com.poesys.accounting.db.transaction.IItem>> {
    private static final long serialVersionUID = 1L;
    private static final int BATCH_SIZE = 100;

    /**
     * Create an UpdateReceivablesSetter object.
     */
    public UpdateReceivablesSetter() {
      super("com.poesys.accounting.db.transaction", 2147483647);
    }

    @Override
    protected void doChanged(java.util.Collection<com.poesys.accounting.db.transaction.IItem> dtos) {
      // receivables source: TransformToProperty +
      // AddToManyAssociationCollectionProperties
      // Immutable: false
      com.poesys.db.dao.IDaoManager manager =
        com.poesys.db.dao.DaoManagerFactory.getManager(subsystem);

      com.poesys.db.dao.IDaoFactory<com.poesys.accounting.db.transaction.IItem> factory =
        manager.getFactory(com.poesys.accounting.db.transaction.Item.class.getName(),
                           subsystem,
                           2147483647);
      com.poesys.db.dao.update.IUpdateBatch<com.poesys.accounting.db.transaction.IItem> updater =
        factory.getUpdateBatch(new com.poesys.accounting.db.transaction.sql.UpdateItem());

      // Update the object of the leaf class.
      updater.update(dtos, dtos.size() / 2);
      // Complete the update by setting the DTOs to EXISTING status.
      for (com.poesys.db.dto.IDbDto dto : dtos) {
        if (dto.getStatus() == Status.CHANGED) {
          dto.setExisting();
        }
      }
    }

    @Override
    protected void doDeleted(java.util.Collection<com.poesys.accounting.db.transaction.IItem> dtos) {
      com.poesys.db.dao.IDaoManager manager =
        com.poesys.db.dao.DaoManagerFactory.getManager(subsystem);
      com.poesys.db.dao.IDaoFactory<com.poesys.accounting.db.transaction.IItem> factory =
        manager.getFactory(com.poesys.accounting.db.transaction.Item.class.getName(),
                           subsystem,
                           2147483647);
      com.poesys.db.dao.delete.IDeleteBatch<com.poesys.accounting.db.transaction.IItem> dao =
        factory.getDeleteBatch(new com.poesys.accounting.db.transaction.sql.DeleteItem());
      dao.delete(dtos, BATCH_SIZE);
    }

    @Override
    protected void doNew(java.util.Collection<com.poesys.accounting.db.transaction.IItem> dtos) {
      com.poesys.db.dao.IDaoManager manager =
        com.poesys.db.dao.DaoManagerFactory.getManager(subsystem);

      com.poesys.db.dao.IDaoFactory<com.poesys.accounting.db.transaction.IItem> factory =
        manager.getFactory(com.poesys.accounting.db.transaction.Item.class.getName(),
                           subsystem,
                           2147483647);
      com.poesys.db.dao.insert.IInsertBatch<com.poesys.accounting.db.transaction.IItem> inserter =
        factory.getInsertBatch(new com.poesys.accounting.db.transaction.sql.InsertItem());

      // Insert the object of the current class after enabling nested inserts,
      // which will allow connecting up linked objects to any of the inserted
      // classes.
      for (com.poesys.db.dto.IDbDto dto : dtos) {
        dto.setSuppressNestedInserts(false);
      }
      inserter.insert(dtos, dtos.size() / 2);
    }

    @Override
    protected java.util.Collection<com.poesys.accounting.db.transaction.IItem> getDtos() {
      return receivables;
    }

    @Override
    protected String getClassName() {
      return com.poesys.accounting.db.transaction.Item.class.getName();
    }
  }

  @Override
  public void addReceivableItem(com.poesys.accounting.db.transaction.IItem object) {
    if (receivables == null) {
      // Association not yet created, create it.
      receivables =
        new java.util.ArrayList<com.poesys.accounting.db.transaction.IItem>();
    }
    receivables.add(object);
    // Add the primary key to the primary key array.
    if (receivableKeys != null) {
      receivableKeys.clear();
    } else {
      receivableKeys = new java.util.ArrayList<com.poesys.db.pk.IPrimaryKey>();
    }
    receivableKeys.add(object.getPrimaryKey());
  }

  /**
   * Post-processing setter for post-processing nested to-many association
   * reimbursements.
   */
  private class PostProcessReimbursementsSetter extends
      com.poesys.db.dto.AbstractPostProcessSetter {
    private static final long serialVersionUID = 1L;

    // Association reimbursingItems source:
    // AddAssociationClassCollectionProperties

    /**
     * Create an PostProcessReimbursementsSetter object.
     */
    public PostProcessReimbursementsSetter() {
      super("com.poesys.accounting.db.transaction", 2147483647);
    }

    @Override
    protected String getClassName() {
      return com.poesys.accounting.db.transaction.Reimbursement.class.getName();
    }

    @SuppressWarnings("unchecked")
    @Override
    protected java.util.Collection<com.poesys.db.dto.IDbDto> getDtos() {
      java.util.Collection<? extends com.poesys.db.dto.IDbDto> dtos =
        reimbursingItems;
      return (java.util.Collection<com.poesys.db.dto.IDbDto>)dtos;
    }
  }

  /**
   * Insert setter for inserting nested to-many association reimbursements.
   *
   * @see com.poesys.accounting.db.transaction.sql.InsertReimbursement
   */
  private class InsertReimbursementsSetter extends
      com.poesys.db.dto.AbstractInsertSetter {
    private static final long serialVersionUID = 1L;

    // Association receivables source: AddAssociationClassCollectionProperties

    /**
     * Create an InsertReimbursementsSetter object.
     */
    public InsertReimbursementsSetter() {
      super("com.poesys.accounting.db.transaction", 2147483647);
    }

    @Override
    protected String getClassName() {
      return com.poesys.accounting.db.transaction.Reimbursement.class.getName();
    }

    @SuppressWarnings("unchecked")
    @Override
    protected java.util.Collection<com.poesys.db.dto.IDbDto> getDtos() {
      java.util.Collection<? extends com.poesys.db.dto.IDbDto> dtos =
        receivables;
      return (java.util.Collection<com.poesys.db.dto.IDbDto>)dtos;
    }

    @Override
    protected boolean createKey() {
      return true;
    }
  }

  /**
   * Setter for processing added reimbursements and updated reimbursements.
   * Deleted reimbursements are deleted in the database cascade delete.
   */

  private class UpdateReimbursementsSetter
      extends
      com.poesys.db.dto.AbstractProcessNestedObjects<com.poesys.accounting.db.transaction.IReimbursement, java.util.Collection<com.poesys.accounting.db.transaction.IReimbursement>> {
    private static final long serialVersionUID = 1L;
    private static final int BATCH_SIZE = 100;

    /**
     * Create an UpdateReimbursementsSetter object.
     */
    public UpdateReimbursementsSetter() {
      super("com.poesys.accounting.db.transaction", 2147483647);
    }

    @Override
    protected void doChanged(java.util.Collection<com.poesys.accounting.db.transaction.IReimbursement> dtos) {
      // receivables source: AddAssociationClassCollectionProperties
      // Immutable: false
      com.poesys.db.dao.IDaoManager manager =
        com.poesys.db.dao.DaoManagerFactory.getManager(subsystem);

      com.poesys.db.dao.IDaoFactory<com.poesys.accounting.db.transaction.IReimbursement> factory =
        manager.getFactory(com.poesys.accounting.db.transaction.Reimbursement.class.getName(),
                           subsystem,
                           2147483647);
      com.poesys.db.dao.update.IUpdateBatch<com.poesys.accounting.db.transaction.IReimbursement> updater =
        factory.getUpdateBatch(new com.poesys.accounting.db.transaction.sql.UpdateReimbursement());

      // Update the object of the leaf class.
      updater.update(dtos, dtos.size() / 2);
      // Complete the update by setting the DTOs to EXISTING status.
      for (com.poesys.db.dto.IDbDto dto : dtos) {
        if (dto.getStatus() == Status.CHANGED) {
          dto.setExisting();
        }
      }
    }

    @Override
    protected void doDeleted(java.util.Collection<com.poesys.accounting.db.transaction.IReimbursement> dtos) {
      com.poesys.db.dao.IDaoManager manager =
        com.poesys.db.dao.DaoManagerFactory.getManager(subsystem);
      com.poesys.db.dao.IDaoFactory<com.poesys.accounting.db.transaction.IReimbursement> factory =
        manager.getFactory(com.poesys.accounting.db.transaction.Reimbursement.class.getName(),
                           subsystem,
                           2147483647);
      com.poesys.db.dao.delete.IDeleteBatch<com.poesys.accounting.db.transaction.IReimbursement> dao =
        factory.getDeleteBatch(new com.poesys.accounting.db.transaction.sql.DeleteReimbursement());
      dao.delete(dtos, BATCH_SIZE);
    }

    @Override
    protected void doNew(java.util.Collection<com.poesys.accounting.db.transaction.IReimbursement> dtos) {
      com.poesys.db.dao.IDaoManager manager =
        com.poesys.db.dao.DaoManagerFactory.getManager(subsystem);

      com.poesys.db.dao.IDaoFactory<com.poesys.accounting.db.transaction.IReimbursement> factory =
        manager.getFactory(com.poesys.accounting.db.transaction.Reimbursement.class.getName(),
                           subsystem,
                           2147483647);
      com.poesys.db.dao.insert.IInsertBatch<com.poesys.accounting.db.transaction.IReimbursement> inserter =
        factory.getInsertBatch(new com.poesys.accounting.db.transaction.sql.InsertReimbursement());

      // Insert the object of the current class after enabling nested inserts,
      // which will allow connecting up linked objects to any of the inserted
      // classes.
      for (com.poesys.db.dto.IDbDto dto : dtos) {
        dto.setSuppressNestedInserts(false);
      }
      inserter.insert(dtos, dtos.size() / 2);
    }

    @Override
    protected java.util.Collection<com.poesys.accounting.db.transaction.IReimbursement> getDtos() {
      return reimbursements;
    }

    @Override
    protected String getClassName() {
      return com.poesys.accounting.db.transaction.Reimbursement.class.getName();
    }
  }

  @Override
  public void addReimbursement(com.poesys.accounting.db.transaction.IReimbursement object) {
    if (reimbursements == null) {
      // Association not yet created, create it.
      reimbursements =
        new java.util.ArrayList<com.poesys.accounting.db.transaction.IReimbursement>();
    }
    reimbursements.add(object);
    // Add the primary key to the primary key array.
    if (reimbursementsKeys != null) {
      reimbursementsKeys.clear();
    } else {
      reimbursementsKeys =
        new java.util.ArrayList<com.poesys.db.pk.IPrimaryKey>();
    }
    reimbursementsKeys.add(object.getPrimaryKey());
  }

  /**
   * Create an empty Item for use in building a new object. The concrete
   * subclass must call this constructor.
   */
  public AbstractItem() {
    abstractClass = false;
    createInserters();

    // Setter arrays (create if null)
    if (querySetters == null) {
      querySetters = new java.util.ArrayList<com.poesys.db.dto.ISet>();
    }
    if (insertSetters == null) {
      insertSetters = new java.util.ArrayList<com.poesys.db.dto.ISet>();
    }
    if (preSetters == null) {
      preSetters = new java.util.ArrayList<com.poesys.db.dto.ISet>();
    }
    if (postSetters == null) {
      postSetters = new java.util.ArrayList<com.poesys.db.dto.ISet>();
    }
    if (postProcessSetters == null) {
      postProcessSetters = new java.util.ArrayList<com.poesys.db.dto.ISet>();
    }
    if (readObjectSetters == null) {
      readObjectSetters = new java.util.ArrayList<com.poesys.db.dto.ISet>();
    }

    // Add the setters for the transaction property.
    querySetters.add(new QueryTransactionSetter());
    preSetters.add(new InsertTransactionSetter());
    postSetters.add(new UpdateTransactionSetter());
    postProcessSetters.add(new PostProcessTransactionSetter());

    // Add the setters for the account property.
    querySetters.add(new QueryAccountSetter());
    preSetters.add(new InsertAccountSetter());
    postSetters.add(new UpdateAccountSetter());
    postProcessSetters.add(new PostProcessAccountSetter());

    // Add the many-to-many collection setters for the reimbursingItems
    // property.
    insertSetters.add(new InsertReimbursingItemsSetter());
    postSetters.add(new UpdateReimbursingItemsSetter());
    postProcessSetters.add(new PostProcessReimbursingItemsSetter());

    // Add the many-to-many collection setters for the receivables property.
    insertSetters.add(new InsertReceivablesSetter());
    postSetters.add(new UpdateReceivablesSetter());
    postProcessSetters.add(new PostProcessReceivablesSetter());

    // Add the many-to-many collection setters for the reimbursements property.
    insertSetters.add(new InsertReimbursementsSetter());
    postSetters.add(new UpdateReimbursementsSetter());
    postProcessSetters.add(new PostProcessReimbursementsSetter());
  }

  /**
   * Create a Item. The concrete subclass must call this constructor.
   *
   * @param key the primary key of the Item
   * @param transactionId composite super-key attribute that uniquely identifies
   *          child combined with child sub-key and any other parent super-keys
   * @param orderNumber
   * @param amount the monetary amount in dollars of the transaction item
   * @param debit whether the item is a debit (true) or credit (false); default
   *          value is the debit-default value of the account
   * @param checked whether the value and details of the transaction item have
   *          been verified and reconciled
   * @param accountName foreign key used by setter to query associated object
   * @param entityName foreign key used by setter to query associated object
   */
  public AbstractItem(IPrimaryKey key,
                      java.math.BigInteger transactionId,
                      java.lang.Integer orderNumber,
                      java.lang.Double amount,
                      java.lang.Boolean debit,
                      java.lang.Boolean checked,
                      java.lang.String accountName,
                      java.lang.String entityName) {
    this.key = key;

    this.transactionId = transactionId;

    if (transactionId == null) {
      throw new com.poesys.db.InvalidParametersException("transactionId is required for "
                                                         + key.getValueList());
    }

    this.orderNumber = orderNumber;

    if (orderNumber == null) {
      throw new com.poesys.db.InvalidParametersException("orderNumber is required for "
                                                         + key.getValueList());
    }

    this.amount = amount;

    if (amount == null) {
      throw new com.poesys.db.InvalidParametersException("amount is required for "
                                                         + key.getValueList());
    }

    this.debit = debit;

    if (debit == null) {
      throw new com.poesys.db.InvalidParametersException("debit is required for "
                                                         + key.getValueList());
    }

    this.checked = checked;

    if (checked == null) {
      throw new com.poesys.db.InvalidParametersException("checked is required for "
                                                         + key.getValueList());
    }

    this.accountName = accountName;

    if (accountName == null) {
      throw new com.poesys.db.InvalidParametersException("accountName is required for "
                                                         + key.getValueList());
    }

    this.entityName = entityName;

    if (entityName == null) {
      throw new com.poesys.db.InvalidParametersException("entityName is required for "
                                                         + key.getValueList());
    }

    // Setter arrays (create if null)
    if (querySetters == null) {
      querySetters = new java.util.ArrayList<com.poesys.db.dto.ISet>();
    }
    if (insertQuerySetters == null) {
      insertQuerySetters = new java.util.ArrayList<com.poesys.db.dto.ISet>();
    }
    if (insertSetters == null) {
      insertSetters = new java.util.ArrayList<com.poesys.db.dto.ISet>();
    }
    if (preSetters == null) {
      preSetters = new java.util.ArrayList<com.poesys.db.dto.ISet>();
    }
    if (postSetters == null) {
      postSetters = new java.util.ArrayList<com.poesys.db.dto.ISet>();
    }
    if (postProcessSetters == null) {
      postProcessSetters = new java.util.ArrayList<com.poesys.db.dto.ISet>();
    }
    if (readObjectSetters == null) {
      readObjectSetters = new java.util.ArrayList<com.poesys.db.dto.ISet>();
    }

    // Add the setters for the transaction property.
    querySetters.add(new QueryTransactionSetter());
    // Set the object property primary key with a factory method.
    transactionKey =
      com.poesys.accounting.db.transaction.TransactionFactory.getTransactionPrimaryKey(transactionId);
    insertSetters.add(new InsertTransactionSetter());
    preSetters.add(new InsertTransactionSetter());
    postSetters.add(new UpdateTransactionSetter());
    postProcessSetters.add(new PostProcessTransactionSetter());

    // Add a setter to instantiate the required transaction object before
    // insert.
    insertQuerySetters.add(new QueryTransactionSetter());

    // Add the setters for the account property.
    querySetters.add(new QueryAccountSetter());
    // Set the object property primary key with a factory method.
    accountKey =
      com.poesys.accounting.db.account.AccountFactory.getAccountPrimaryKey(accountName,
                                                                           entityName);
    insertSetters.add(new InsertAccountSetter());
    preSetters.add(new InsertAccountSetter());
    postSetters.add(new UpdateAccountSetter());
    postProcessSetters.add(new PostProcessAccountSetter());

    // Add a setter to instantiate the required account object before insert.
    insertQuerySetters.add(new QueryAccountSetter());

    // Add the many-to-many collection setters for the reimbursedItems property.
    insertSetters.add(new InsertReimbursingItemsSetter());
    postSetters.add(new UpdateReimbursingItemsSetter());
    postProcessSetters.add(new PostProcessReimbursingItemsSetter());

    // Add the many-to-many collection setters for the receivables property.
    insertSetters.add(new InsertReceivablesSetter());
    postSetters.add(new UpdateReceivablesSetter());
    postProcessSetters.add(new PostProcessReceivablesSetter());

    // Add the many-to-many collection setters for the reimbursements property.
    insertSetters.add(new InsertReimbursementsSetter());
    postSetters.add(new UpdateReimbursementsSetter());
    postProcessSetters.add(new PostProcessReimbursementsSetter());

    abstractClass = false;
    createInserters();
  }

  /**
   * Read an object from an input stream, de-serializing it. Each generated
   * class must have this private method, which the deserialize method calls
   * through Java reflection on the specific class. The class calls a shared
   * code method to run the readObjectSetters.
   * 
   * @param in the object input stream
   * @throws ClassNotFoundException when a nested object class can't be found
   * @throws IOException when there is an IO problem reading the stream
   */
  private void readObject(java.io.ObjectInputStream in)
      throws java.io.IOException, ClassNotFoundException {
    logger.debug("Deserializing object of class " + this.getClass().getName()
                 + " with readObject in AbstractItem");
    // Do the read-object deserialization.
    deserializer.doReadObject(in, this);
  }

  @Override
  public boolean equals(Object arg0) {
    IItem other = (IItem)arg0;
    return other.getPrimaryKey().equals(key);
  }

  @Override
  public int hashCode() {
    return key.hashCode();
  }

  @Override
  public int compareTo(com.poesys.db.dto.IDbDto o) {
    IItem other = (IItem)o;
    // Sort on the key. Same semantics as equals and hashCode().
    return other.getPrimaryKey().compareTo(key);
  }

  @Override
  public String getSubsystem() {
    return "com.poesys.accounting.db.transaction";
  }

  @Override
  public void markChildrenDeleted() {
    // Only process deletes if child exists.
    if (reimbursingItems != null) {
      for (com.poesys.db.dto.IDbDto dto : reimbursingItems) {
        dto.cascadeDelete();
      }
    }
    // Only process deletes if child exists.
    if (receivables != null) {
      for (com.poesys.db.dto.IDbDto dto : receivables) {
        dto.cascadeDelete();
      }
    }
  }

  @Override
  public IPrimaryKey getPrimaryKey() {
    return key;
  }

  /**
   * Nested property transactionId
   *
   * <p>
   * Composite super-key attribute that uniquely identifies child combined with
   * child sub-key and any other parent super-keys
   * </p>
   *
   * Added by AddGeneratedKeyProperties + AddParentKeyAttributes Class is
   * read/write: true Class is immutable: false Property is read/write: false
   * Property is lazy: false
   */
  private java.math.BigInteger transactionId;

  @Override
  public java.math.BigInteger getTransactionId() {
    return transactionId;
  }

  /**
   * Clear the transactionId data member; override in proxy if lazily loaded,
   * otherwise this method does nothing.
   */
  public void clearTransactionId() {
    // Override in proxy if lazily loaded; otherwise does nothing
  }

  @Override
  public void setTransactionId(java.math.BigInteger transactionId)
      throws com.poesys.db.InvalidParametersException {
    if (transactionId == null) {
      throw new com.poesys.db.InvalidParametersException("transactionId is required");
    }

    this.transactionId = transactionId;
    setChanged();
  }
  /**
   * Nested property orderNumber
   *
   * Added by AddExplicitSubKeyProperties + addNaturalSubkeyOnClass Class is
   * read/write: true Class is immutable: false Property is read/write: false
   * Property is lazy: false
   */
  private java.lang.Integer orderNumber;

  @Override
  public java.lang.Integer getOrderNumber() {
    return orderNumber;
  }

  /**
   * Clear the orderNumber data member; override in proxy if lazily loaded,
   * otherwise this method does nothing.
   */
  public void clearOrderNumber() {
    // Override in proxy if lazily loaded; otherwise does nothing
  }

  @Override
  public void setOrderNumber(java.lang.Integer orderNumber)
      throws com.poesys.db.InvalidParametersException {
    if (orderNumber == null) {
      throw new com.poesys.db.InvalidParametersException("orderNumber is required");
    }

    this.orderNumber = orderNumber;
    setChanged();
  }

  /**
   * Nested property amount
   *
   * <p>
   * the monetary amount in dollars of the transaction item
   * </p>
   *
   * Added by AddLocalAttributeProperties Class is read/write: true Class is
   * immutable: false Property is read/write: true Property is lazy: false
   */
  private java.lang.Double amount;

  @Override
  public java.lang.Double getAmount() {
    return amount;
  }

  /**
   * Clear the amount data member; override in proxy if lazily loaded, otherwise
   * this method does nothing.
   */
  public void clearAmount() {
    // Override in proxy if lazily loaded; otherwise does nothing
  }

  @Override
  public void setAmount(java.lang.Double amount)
      throws com.poesys.db.InvalidParametersException {
    if (amount == null) {
      throw new com.poesys.db.InvalidParametersException("amount is required");
    }

    this.amount = amount;
    setChanged();
  }

  /**
   * Nested property debit
   *
   * <p>
   * whether the item is a debit (true) or credit (false); default value is the
   * debit-default value of the account
   * </p>
   *
   * Added by AddLocalAttributeProperties Class is read/write: true Class is
   * immutable: false Property is read/write: true Property is lazy: false
   */
  private java.lang.Boolean debit;

  @Override
  public java.lang.Boolean getDebit() {
    return debit;
  }

  /**
   * Clear the debit data member; override in proxy if lazily loaded, otherwise
   * this method does nothing.
   */
  public void clearDebit() {
    // Override in proxy if lazily loaded; otherwise does nothing
  }

  @Override
  public void setDebit(java.lang.Boolean debit)
      throws com.poesys.db.InvalidParametersException {
    if (debit == null) {
      throw new com.poesys.db.InvalidParametersException("debit is required");
    }

    this.debit = debit;
    setChanged();
  }

  /**
   * Nested property checked
   *
   * <p>
   * whether the value and details of the transaction item have been verified
   * and reconciled
   * </p>
   *
   * Added by AddLocalAttributeProperties Class is read/write: true Class is
   * immutable: false Property is read/write: true Property is lazy: false
   */
  private java.lang.Boolean checked;

  @Override
  public java.lang.Boolean getChecked() {
    return checked;
  }

  /**
   * Clear the checked data member; override in proxy if lazily loaded,
   * otherwise this method does nothing.
   */
  public void clearChecked() {
    // Override in proxy if lazily loaded; otherwise does nothing
  }

  @Override
  public void setChecked(java.lang.Boolean checked)
      throws com.poesys.db.InvalidParametersException {
    if (checked == null) {
      throw new com.poesys.db.InvalidParametersException("checked is required");
    }

    this.checked = checked;
    setChanged();
  }

  /**
   * Nested property transaction
   *
   * <p>
   * the transaction that owns the item (the parent)
   * </p>
   *
   * Added by AddToOneAssociationRequiredObjectProperties Class is read/write:
   * true Class is immutable: false Property is read/write: true Property is
   * lazy: false
   */
  private com.poesys.accounting.db.transaction.ITransaction transaction;

  @Override
  public com.poesys.accounting.db.transaction.ITransaction getTransaction() {
    return transaction;
  }

  /**
   * Clear the transaction data member; override in proxy if lazily loaded,
   * otherwise this method does nothing.
   */
  public void clearTransaction() {
    // Override in proxy if lazily loaded; otherwise does nothing
  }

  @Override
  public void setTransaction(com.poesys.accounting.db.transaction.ITransaction transaction)
      throws com.poesys.db.InvalidParametersException {
    if (transaction == null) {
      throw new com.poesys.db.InvalidParametersException("transaction is required");
    }

    this.transaction = transaction;
    setChanged();
  }

  /**
   * Nested property account
   *
   * <p>
   * the account to which to associate the flow of funds for the item
   * </p>
   *
   * Added by AddToOneAssociationRequiredObjectProperties Class is read/write:
   * true Class is immutable: false Property is read/write: true Property is
   * lazy: false
   */
  private com.poesys.accounting.db.account.IAccount account;

  @Override
  public com.poesys.accounting.db.account.IAccount getAccount() {
    return account;
  }

  /**
   * Clear the account data member; override in proxy if lazily loaded,
   * otherwise this method does nothing.
   */
  public void clearAccount() {
    // Override in proxy if lazily loaded; otherwise does nothing
  }

  @Override
  public void setAccount(com.poesys.accounting.db.account.IAccount account)
      throws com.poesys.db.InvalidParametersException {
    if (account == null) {
      throw new com.poesys.db.InvalidParametersException("account is required");
    }

    this.account = account;
    setChanged();
  }

  /**
   * Nested property accountName
   *
   * <p>
   * Foreign key used by setter to query associated object
   * </p>
   *
   * Added by AddExplicitSubKeyProperties + addNaturalSubkeyOnClass +
   * AddToOneAssociationAttributeProperties Class is read/write: true Class is
   * immutable: false Property is read/write: false Property is lazy: false
   */
  private java.lang.String accountName;

  @Override
  public java.lang.String getAccountName() {
    return accountName;
  }

  /**
   * Clear the accountName data member; override in proxy if lazily loaded,
   * otherwise this method does nothing.
   */
  public void clearAccountName() {
    // Override in proxy if lazily loaded; otherwise does nothing
  }

  @Override
  public void setAccountName(java.lang.String accountName)
      throws com.poesys.db.InvalidParametersException {
    if (accountName == null) {
      throw new com.poesys.db.InvalidParametersException("accountName is required");
    }

    this.accountName = accountName;
    setChanged();
  }

  /**
   * Nested property entityName
   *
   * <p>
   * Foreign key used by setter to query associated object
   * </p>
   *
   * Added by AddNaturalKeyProperties + AddParentKeyAttributes +
   * AddToOneAssociationAttributeProperties Class is read/write: true Class is
   * immutable: false Property is read/write: false Property is lazy: false
   */
  private java.lang.String entityName;

  @Override
  public java.lang.String getEntityName() {
    return entityName;
  }

  /**
   * Clear the entityName data member; override in proxy if lazily loaded,
   * otherwise this method does nothing.
   */
  public void clearEntityName() {
    // Override in proxy if lazily loaded; otherwise does nothing
  }

  @Override
  public void setEntityName(java.lang.String entityName)
      throws com.poesys.db.InvalidParametersException {
    if (entityName == null) {
      throw new com.poesys.db.InvalidParametersException("entityName is required");
    }

    this.entityName = entityName;
    setChanged();
  }

  /**
   * Nested property reimbursingItems
   *
   * <p>
   * the set of reimbursed items; these are items
   * </p>
   *
   * Added by TransformToProperty + AddToManyAssociationCollectionProperties
   * Class is read/write: true Class is immutable: false Property is read/write:
   * true Property is lazy: true
   */
  // Doesn't serialize; package access allows proxy to set on readObject()
  transient java.util.Collection<com.poesys.accounting.db.transaction.IItem> reimbursingItems;
  // Ordered list of keys of the objects in the reimbursingItems list
  transient java.util.List<com.poesys.db.pk.IPrimaryKey> reimbursedItemKeys =
    new java.util.ArrayList<com.poesys.db.pk.IPrimaryKey>();

  @Override
  public java.util.Collection<com.poesys.accounting.db.transaction.IItem> getReimbursingItems() {
    return reimbursingItems;
  }

  @Override
  public void clearReimbursingItems() {
    // Override in proxy if lazily loaded; otherwise does nothing
  }

  @Override
  public void setReimbursingItems(java.util.Collection<com.poesys.accounting.db.transaction.IItem> reimbursingItems) {
    this.reimbursingItems = reimbursingItems;
    // Add the primary keys of the new collection to the serialized key list.
    if (reimbursedItemKeys != null) {
      reimbursedItemKeys.clear();
    } else {
      // Allocate a new, empty list of primary keys.
      reimbursedItemKeys =
        new java.util.ArrayList<com.poesys.db.pk.IPrimaryKey>();
    }
    if (reimbursingItems != null) {
      if (reimbursedItemKeys != null) {
        reimbursedItemKeys.clear();
      } else {
        reimbursedItemKeys =
          new java.util.ArrayList<com.poesys.db.pk.IPrimaryKey>();
      }
      for (com.poesys.db.dto.IDbDto object : reimbursingItems) {
        reimbursedItemKeys.add(object.getPrimaryKey());
      }
    }
    setChanged();
  }

  /**
   * Nested property receivables
   *
   * <p>
   * the set of receivable items reimbursed by this item
   * </p>
   *
   * Added by TransformToProperty + AddToManyAssociationCollectionProperties
   * Class is read/write: true Class is immutable: false Property is read/write:
   * true Property is lazy: true
   */
  // Doesn't serialize; package access allows proxy to set on readObject()
  transient java.util.Collection<com.poesys.accounting.db.transaction.IItem> receivables;
  // Ordered list of keys of the objects in the receivables list
  transient java.util.List<com.poesys.db.pk.IPrimaryKey> receivableKeys =
    new java.util.ArrayList<com.poesys.db.pk.IPrimaryKey>();

  @Override
  public java.util.Collection<com.poesys.accounting.db.transaction.IItem> getReceivables() {
    return receivables;
  }

  @Override
  public void clearReceivables() {
    // Override in proxy if lazily loaded; otherwise does nothing
  }

  @Override
  public void setReceivables(java.util.Collection<com.poesys.accounting.db.transaction.IItem> receivables) {
    this.receivables = receivables;
    // Add the primary keys of the new collection to the serialized key list.
    if (receivableKeys != null) {
      receivableKeys.clear();
    } else {
      // Allocate a new, empty list of primary keys.
      receivableKeys = new java.util.ArrayList<com.poesys.db.pk.IPrimaryKey>();
    }
    if (receivables != null) {
      if (receivableKeys != null) {
        receivableKeys.clear();
      } else {
        receivableKeys =
          new java.util.ArrayList<com.poesys.db.pk.IPrimaryKey>();
      }
      for (com.poesys.db.dto.IDbDto object : receivables) {
        receivableKeys.add(object.getPrimaryKey());
      }
    }
    setChanged();
  }

  /**
   * Nested property reimbursements, the collection of association objects as
   * opposed to the associated objects (receivables and reimbursingItems).
   *
   * <p>
   * Collection of association class objects (not the associated objects)
   * </p>
   *
   * Added by AddAssociationClassCollectionProperties Class is read/write: true
   * Class is immutable: false Property is read/write: true Property is lazy:
   * true
   */
  // Doesn't serialize; package access allows proxy to set on readObject()
  transient java.util.Collection<com.poesys.accounting.db.transaction.IReimbursement> reimbursements;
  // Ordered list of keys of the objects in the reimbursements collection
  transient java.util.List<com.poesys.db.pk.IPrimaryKey> reimbursementsKeys =
    new java.util.ArrayList<com.poesys.db.pk.IPrimaryKey>();

  @Override
  public java.util.Collection<com.poesys.accounting.db.transaction.IReimbursement> getReimbursements() {
    return reimbursements;
  }

  @Override
  public void clearReimbursements() {
    // Override in proxy if lazily loaded; otherwise does nothing
  }

  @Override
  public void setReimbursements(java.util.Collection<com.poesys.accounting.db.transaction.IReimbursement> reimbursements)
      throws com.poesys.db.InvalidParametersException {
    if (reimbursements == null) {
      throw new com.poesys.db.InvalidParametersException("reimbursingItems is required");
    }

    this.reimbursements = reimbursements;
    // Add the primary keys of the new collection to the serialized key list.
    if (reimbursementsKeys != null) {
      reimbursementsKeys.clear();
    } else {
      // Allocate a new, empty list of primary keys.
      reimbursementsKeys =
        new java.util.ArrayList<com.poesys.db.pk.IPrimaryKey>();
    }
    if (reimbursements != null) {
      if (reimbursementsKeys != null) {
        reimbursementsKeys.clear();
      } else {
        reimbursementsKeys =
          new java.util.ArrayList<com.poesys.db.pk.IPrimaryKey>();
      }
      for (com.poesys.db.dto.IDbDto object : reimbursements) {
        reimbursementsKeys.add(object.getPrimaryKey());
      }
    }
    setChanged();
  }

  @Override
  public void update(com.poesys.db.dto.ISubject subject,
                     com.poesys.db.dao.DataEvent event) {

    // Clean up reimbursingItems.
    if (subject != null
        && subject instanceof com.poesys.accounting.db.transaction.IReimbursement
        && event == com.poesys.db.dao.DataEvent.DELETE
        && reimbursingItems != null) {
      // Delete to-many reimbursingItems child from collection
      reimbursingItems.remove(subject);
      subject.detach(this, com.poesys.db.dao.DataEvent.MARKED_DELETED);
      subject.detach(this, com.poesys.db.dao.DataEvent.DELETE);
    }

    // Clean up receivables.
    if (subject != null
        && subject instanceof com.poesys.accounting.db.transaction.IReimbursement
        && event == com.poesys.db.dao.DataEvent.DELETE && receivables != null) {
      // Delete to-many receivables child from collection
      receivables.remove(subject);
      subject.detach(this, com.poesys.db.dao.DataEvent.MARKED_DELETED);
      subject.detach(this, com.poesys.db.dao.DataEvent.DELETE);
    }

    // Cascade delete to reimbursingItems.
    if (event == com.poesys.db.dao.DataEvent.MARKED_DELETED
        && reimbursingItems != null) {
      // Mark reimbursingItems association object cascade-deleted.
      outer: for (com.poesys.accounting.db.transaction.IReimbursement value : reimbursements) {
        com.poesys.db.pk.AssociationPrimaryKey keys =
          (com.poesys.db.pk.AssociationPrimaryKey)value.getPrimaryKey();
        for (com.poesys.db.pk.IPrimaryKey key : keys.getKeyListCopy()) {
          if (key.equals(subject.getPrimaryKey())) {
            value.cascadeDelete();
            break outer;
          }
        }
      }
    }

    // Cascade delete to receivables.
    if (event == com.poesys.db.dao.DataEvent.MARKED_DELETED
        && receivables != null) {
      // Mark receivables association object cascade-deleted.
      outer: for (com.poesys.accounting.db.transaction.IReimbursement value : reimbursements) {
        com.poesys.db.pk.AssociationPrimaryKey keys =
          (com.poesys.db.pk.AssociationPrimaryKey)value.getPrimaryKey();
        for (com.poesys.db.pk.IPrimaryKey key : keys.getKeyListCopy()) {
          if (key.equals(subject.getPrimaryKey())) {
            value.cascadeDelete();
            break outer;
          }
        }
      }
    }
  }

  /**
   * Create the inserters for the Item.
   */
  private void createInserters() {
    com.poesys.db.dao.IDaoManager manager =
      com.poesys.db.dao.DaoManagerFactory.getManager(getSubsystem());
    final com.poesys.db.dao.IDaoFactory<com.poesys.accounting.db.transaction.IItem> itemFactory =
      manager.getFactory("com.poesys.accounting.db.transaction.Item",
                         getSubsystem(),
                         2147483647);
    com.poesys.db.dao.insert.IInsertSql<IItem> sql =
      new com.poesys.accounting.db.transaction.sql.InsertItem();
    com.poesys.db.dao.insert.IInsert<IItem> inserter =
      itemFactory.getInsert(sql, true);
    inserters.add(inserter);
  }
}