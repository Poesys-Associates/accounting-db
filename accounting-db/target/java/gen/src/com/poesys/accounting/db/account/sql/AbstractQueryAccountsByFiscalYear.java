/**
 * Copyright 2016 Poesys Associates. All rights reserved.
 */
// Generated by AndroMDA Poesys/DB cartridge: DO NOT EDIT DIRECTLY.
// Template: AbstractQueryAssociatedManyToManyObjects.vsl


package com.poesys.accounting.db.account.sql;


import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;

import com.poesys.db.dao.query.IParameterizedQuerySql;
import com.poesys.db.pk.IPrimaryKey;



/**
 * <p>
 * A query Command pattern object that implements a SQL query of a collection of 
 * Account objects using the primary key of an associated 
 * FiscalYear object through the association Accounts using the 
 * association class FiscalYearAccount. This association is a many-to-many 
 * association from Account to FiscalYear.
 * </p>
 * <p>
 * This SQL specification contains a SQL statement that queries a collection of
 * Account objects from the database table Account by
 * joining to the database table FiscalYearAccount and using the 
 * primary key from FiscalYear to query the collection.
 * </p>
 * 
 * @author Poesys/DB Cartridge
 */
public abstract class AbstractQueryAccountsByFiscalYear 
    implements IParameterizedQuerySql<com.poesys.accounting.db.account.IAccount, com.poesys.accounting.db.account.IFiscalYear> {
  /** SQL query statement for Account */
  private static final String SQL =
    "SELECT a.entityName, a.accountName, a.description, a.debitDefault, a.active, CapitalAccount.ownership, CapitalAccount.capitalEntityName, DistributionAccount.capitalEntityName, SimpleAccount.receivable, CASE WHEN CapitalAccount.accountName IS NOT NULL THEN 'CapitalAccount' WHEN CapitalAccount.entityName IS NOT NULL THEN 'CapitalAccount' WHEN DistributionAccount.accountName IS NOT NULL THEN 'DistributionAccount' WHEN DistributionAccount.entityName IS NOT NULL THEN 'DistributionAccount' WHEN SimpleAccount.accountName IS NOT NULL THEN 'SimpleAccount' WHEN SimpleAccount.entityName IS NOT NULL THEN 'SimpleAccount' ELSE NULL END AS discriminant FROM Account a JOIN FiscalYearAccount b ON a.accountName = b.accountName AND a.entityName = b.entityName LEFT OUTER JOIN CapitalAccount CapitalAccount ON a.accountName = CapitalAccount.accountName AND a.entityName = CapitalAccount.entityName LEFT OUTER JOIN DistributionAccount DistributionAccount ON a.accountName = DistributionAccount.accountName AND a.entityName = DistributionAccount.entityName LEFT OUTER JOIN SimpleAccount SimpleAccount ON a.accountName = SimpleAccount.accountName AND a.entityName = SimpleAccount.entityName WHERE b.year = ?";

  @Override
  public void bindParameters(PreparedStatement stmt, com.poesys.accounting.db.account.IFiscalYear parameters) {
    // Set the parameters starting with the first parameter.
    parameters.getPrimaryKey().setParams(stmt, 1);
  }

  @Override
  public String getParameterValues(com.poesys.accounting.db.account.IFiscalYear parameters) {
    // Create the output string with the key parameters.
    return parameters.getPrimaryKey().getValueList();
  }

  @Override
  public com.poesys.accounting.db.account.IAccount getData(ResultSet rs) {
    com.poesys.accounting.db.account.IAccount data = null;
    try {
      // Account has subclasses, so the query returns an object of the actual
      // type rather than just of type Account. It uses a discriminant expression
      // that the result set returns to figure out which class to instantiate.
    
      // Get the discriminant from the result set.
      String discriminant = rs.getString("discriminant");
      // Check for CapitalAccount, set return only if not already set
      if (discriminant != null && discriminant.equals("CapitalAccount") && data == null) {
        // Use the account factory to get the data.
        IPrimaryKey key = 
          com.poesys.accounting.db.account.AccountFactory.getCapitalAccountPrimaryKey(rs, "");
        data = com.poesys.accounting.db.account.AccountFactory.getCapitalAccountData(key, rs);
      }
      // Check for DistributionAccount, set return only if not already set
      if (discriminant != null && discriminant.equals("DistributionAccount") && data == null) {
        // Use the account factory to get the data.
        IPrimaryKey key = 
          com.poesys.accounting.db.account.AccountFactory.getDistributionAccountPrimaryKey(rs, "");
        data = com.poesys.accounting.db.account.AccountFactory.getDistributionAccountData(key, rs);
      }
      // Check for SimpleAccount, set return only if not already set
      if (discriminant != null && discriminant.equals("SimpleAccount") && data == null) {
        // Use the account factory to get the data.
        IPrimaryKey key = 
          com.poesys.accounting.db.account.AccountFactory.getSimpleAccountPrimaryKey(rs, "");
        data = com.poesys.accounting.db.account.AccountFactory.getSimpleAccountData(key, rs);
      }
    } catch (com.poesys.db.InvalidParametersException | SQLException e) {
      throw new com.poesys.db.DbErrorException("Error getting data", e);
    }
    
    return data;
  }

  @Override
  public IPrimaryKey getPrimaryKey(ResultSet rs) {
    try {
      return com.poesys.accounting.db.account.AccountFactory.getAccountPrimaryKey(rs, "");
    } catch (com.poesys.db.InvalidParametersException | SQLException e) {
      throw new com.poesys.db.DbErrorException("Error getting primary key", e);
    }
  }

  @Override
  public String getSql() {
    return SQL;
  }
}