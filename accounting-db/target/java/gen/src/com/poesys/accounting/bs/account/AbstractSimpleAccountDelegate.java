/**
 * Copyright 2016 Poesys Associates. All rights reserved.
 */
// Generated by AndroMDA Poesys/DB cartridge: DO NOT EDIT DIRECTLY.
// Template: AbstractDelegate.vsl

package com.poesys.accounting.bs.account;


import com.poesys.db.connection.IConnectionFactory.DBMS;
import com.poesys.bs.delegate.AbstractDataDelegate;
import com.poesys.bs.delegate.DelegateException;
import com.poesys.db.dao.insert.IInsertSql;
import com.poesys.db.dao.update.IUpdateSql;
import com.poesys.db.dao.delete.IDeleteSql;
import com.poesys.db.dao.query.IKeyQuerySql;
import com.poesys.db.dao.query.IQuerySql;


/**
 * <p>
 * A business delegate that provides an application programming interface for
 * SimpleAccount objects and their dependents. You should not modify this class;
 * instead, override or add methods in the class SimpleAccountDelegate, which
 * specializes this class.
 * </p>
 * 
 * @see SimpleAccountDelegate
 * 
 * @author Poesys/DB Cartridge
 */
public abstract class AbstractSimpleAccountDelegate
    extends AbstractDataDelegate<BsSimpleAccount, com.poesys.accounting.db.account.ISimpleAccount, com.poesys.db.pk.CompositePrimaryKey> {
  
  @SuppressWarnings("unused")
  private static final org.apache.log4j.Logger logger = org.apache.log4j.Logger.getLogger(AbstractSimpleAccountDelegate.class);
  
  /**
   * Create an AbstractSimpleAccountDelegate object by supplying the database
   * subsystem in the database.properties file.
   * 
   * @param subsystem the database subsystem to use in database.properties
   */
  public AbstractSimpleAccountDelegate(String subsystem) {
    super(subsystem, 2147483647);
  }

  /**
   * Create an AbstractSimpleAccountDelegate object by supplying the database
   * subsystem in the database.properties file and a specific DBMS, usually
   * IConnectionFactory.DBMS.JNDI.
   * 
   * @param subsystem the database subsystem to use in database.properties
   * @param dbms the DBMS to use (usually IConnectionFactory.DBMS.JNDI)
   */
  public AbstractSimpleAccountDelegate(String subsystem, DBMS dbms) {
    super(subsystem, dbms, 2147483647);
  }

  @Override
  protected String getClassName() {
    return com.poesys.accounting.db.account.SimpleAccount.class.getName();
  }

  @Override
  protected IInsertSql<com.poesys.accounting.db.account.ISimpleAccount> getInsertSql() {
    return new com.poesys.accounting.db.account.sql.InsertSimpleAccount();
  }

  @Override
  protected IDeleteSql<com.poesys.accounting.db.account.ISimpleAccount> getDeleteSql() {
    return new com.poesys.accounting.db.account.sql.DeleteSimpleAccount();
  }

  @Override
  protected IUpdateSql<com.poesys.accounting.db.account.ISimpleAccount> getUpdateSql() {
    return new com.poesys.accounting.db.account.sql.UpdateSimpleAccount();
  }

  @Override
  protected IKeyQuerySql<com.poesys.accounting.db.account.ISimpleAccount> getQueryByKeySql() {
    return new com.poesys.accounting.db.account.sql.QuerySimpleAccount();
  }

  @Override
  protected IQuerySql<com.poesys.accounting.db.account.ISimpleAccount> getQueryListSql() {
    // Query-All method not required
    return new com.poesys.accounting.db.account.sql.QueryAllSimpleAccount();
  }

  @Override
  protected com.poesys.accounting.bs.account.BsSimpleAccount wrapData(com.poesys.accounting.db.account.ISimpleAccount dto) {
    return new com.poesys.accounting.bs.account.BsSimpleAccount(dto);
  }

  /**
   * <p>
   * Create a new SimpleAccount with data fields.
   * </p>
   * <p>
   * The SimpleAccount class has no key of its own but inherits from a superclass
   * that has a CompositeKey. When you create an instance of this
   * class, the delegate creates a key of that type in the superclass.
   * </p>
   * 
   * @param accountName the account name; unique within the entity
   * @param entityName composite super-key attribute that uniquely identifies child combined with child sub-key and any other parent super-keys
   * @param description text description of the nature of the account
   * @param debitDefault whether the account transaction items default to a debit or credit item; chosen
as the "usual" value for items in this account
   * @param active whether the account is active at the present time; an inactive account does not
appear in lists of accounts available through the user interface but does appear
in reports where referenced by items
   * @param receivable whether this account is a receivable account, representing an asset that is a
debt owed to the accounting entity
   * @return the new SimpleAccount object
   * @throws DelegateException when there is a problem generating the key or
   *             creating the object
   */
  public com.poesys.accounting.bs.account.BsSimpleAccount createSimpleAccount(java.lang.String accountName, java.lang.String entityName, java.lang.String description, java.lang.Boolean debitDefault, java.lang.Boolean active, java.lang.Boolean receivable)
      throws DelegateException {
    // Create the composite key.
    com.poesys.db.pk.IPrimaryKey key = 
      com.poesys.accounting.db.account.AccountFactory.getSimpleAccountPrimaryKey(accountName, entityName);
      
    // Create a data-access DTO proxy (supports lazy loading).
    com.poesys.accounting.db.account.ISimpleAccount dto =
      new com.poesys.accounting.db.account.SimpleAccountProxy(new com.poesys.accounting.db.account.SimpleAccount(key, accountName, entityName, description, debitDefault, active, receivable));

    // Create the business DTO.
    return new com.poesys.accounting.bs.account.BsSimpleAccount(dto);
  }


  @Override
  public void insert(java.util.List<BsSimpleAccount> list) throws DelegateException {
    // Create superclass inserters.
    
    // Account
    final com.poesys.db.dao.IDaoFactory<com.poesys.accounting.db.account.IAccount> accountFactory =
      manager.getFactory("com.poesys.accounting.db.account.Account", "com.poesys.accounting.db.account", 2147483647);
    // Key type: CompositeKey, Inherited Key type: None
    com.poesys.db.dao.insert.IInsertBatch<com.poesys.accounting.db.account.IAccount> accountInserter =
      accountFactory.getInsertBatch(new com.poesys.accounting.db.account.sql.InsertAccount());
    java.util.Collection<com.poesys.accounting.db.account.IAccount> accountDtos = convertDtoList(list);
    
    // SimpleAccount (uses standard class factory from AbstractDataDelegate) None CompositeKey
    com.poesys.db.dao.insert.IInsertBatch<com.poesys.accounting.db.account.ISimpleAccount> simpleAccountInserter =
      factory.getInsertBatch(getInsertSql());
    java.util.Collection<com.poesys.accounting.db.account.ISimpleAccount> simpleAccountDtos = convertDtoList(list);

    try {
      // Insert the superclass objects from the root down. Suppress nested
      // inserts for the superclasses, wait until the concrete class. Also set 
      // pre-insert suppression off to have the root insert linked, to-one class
      // objects.
      for (com.poesys.db.dto.IDbDto dto : simpleAccountDtos) {
        dto.setSuppressNestedInserts(true);
        dto.setSuppressNestedPreInserts(false);
      }
      accountInserter.insert(accountDtos, accountDtos.size() / 2);
      // Undo EXISTING status to allow insert of subclass row.
      for (com.poesys.db.dto.IDbDto dto : accountDtos) {
        dto.undoStatus();
      }
      // Insert the object of the leaf class after enabling nested inserts,
      // which will allow connecting up linked objects to any of the inserted
      // classes.
      for (com.poesys.db.dto.IDbDto dto : simpleAccountDtos) {
        dto.setSuppressNestedInserts(false);
      }
      simpleAccountInserter.insert(simpleAccountDtos, simpleAccountDtos.size() / 2);
    } finally {
      finalizeStatus(simpleAccountDtos, com.poesys.db.dto.IDbDto.Status.EXISTING);
    }
  }

  @Override
  public void process(java.util.List<BsSimpleAccount> list) throws DelegateException {
    // Create the 3 DAOs for inserting, updating, and deleting the concrete object.
    com.poesys.db.dao.insert.IInsertBatch<com.poesys.accounting.db.account.ISimpleAccount> inserter = 
      factory.getInsertBatch(getInsertSql());
    com.poesys.db.dao.update.IUpdateBatch<com.poesys.accounting.db.account.ISimpleAccount> updater = 
      factory.getUpdateBatch(getUpdateSql());
    java.util.Collection<com.poesys.accounting.db.account.ISimpleAccount> dtos = convertDtoList(list);

    // Create the DAOs for inserting or updating the superclasses.
    try {
      // Account
      final com.poesys.db.dao.IDaoFactory<com.poesys.accounting.db.account.IAccount> accountFactory =
        manager.getFactory("com.poesys.accounting.db.account.Account", "com.poesys.accounting.db.account", 2147483647);
      com.poesys.db.dao.insert.IInsertBatch<com.poesys.accounting.db.account.IAccount> accountInserter =
        accountFactory.getInsertBatch(new com.poesys.accounting.db.account.sql.InsertAccount());
      com.poesys.db.dao.update.IUpdateBatch<com.poesys.accounting.db.account.IAccount> accountUpdater =
        accountFactory.getUpdateBatch(new com.poesys.accounting.db.account.sql.UpdateAccount());
      java.util.Collection<com.poesys.accounting.db.account.IAccount> accountDtos = convertDtoList(list);
      // If there is a root superclass, create a deleter for the root class.
      // The delete will cascade through foreign key constraints.
      com.poesys.db.dao.delete.IDeleteBatch<com.poesys.accounting.db.account.IAccount> deleter = 
        accountFactory.getDeleteBatch(new com.poesys.accounting.db.account.sql.DeleteAccount());
      if (deleter != null) {
        deleter.delete(accountDtos, accountDtos.size()/2);
      }
    
      // Insert or update the superclass objects from the root down after 
      // turning off nested inserts.
      for (com.poesys.db.dto.IDbDto dto : dtos) {
        dto.setSuppressNestedInserts(true);
        dto.setSuppressNestedPreInserts(false);
      }
      // Process any inserts for account.
      if (accountInserter != null) {
        accountInserter.insert(accountDtos, accountDtos.size() / 2);
      }

      // Process any updates for account.
      if (accountUpdater != null) {
        accountUpdater.update(accountDtos, accountDtos.size() / 2);
      }
      
      // Insert the leaf object after resetting the nested object insertion to
      // insert any nested objects connecting to any of the inserted classes.
      if (inserter != null) {
        for (com.poesys.db.dto.IDbDto dto : dtos) {
          dto.setSuppressNestedInserts(false);
        }
        inserter.insert(dtos, dtos.size() / 2);
      }
      
      // Update the object.
      if (updater != null) {
        updater.update(dtos, dtos.size() / 2);
      }
    } finally {
      updateChangedToExisting(dtos);
      finalizeStatus(dtos, com.poesys.db.dto.IDbDto.Status.EXISTING);
      finalizeStatus(dtos, com.poesys.db.dto.IDbDto.Status.DELETED);
    }
  }
}
